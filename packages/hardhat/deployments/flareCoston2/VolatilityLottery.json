{
  "address": "0x0e06e51ABB2E402be0e108E50D20005EF2Ea89F3",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prizeAmount",
          "type": "uint256"
        }
      ],
      "name": "LotteryEnded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "participant",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "LotteryEntered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        }
      ],
      "name": "LotteryStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "roundId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "endTime",
          "type": "uint256"
        }
      ],
      "name": "RoundStarted",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BTC_USD_ID",
      "outputs": [
        {
          "internalType": "bytes21",
          "name": "",
          "type": "bytes21"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ETH_USD_ID",
      "outputs": [
        {
          "internalType": "bytes21",
          "name": "",
          "type": "bytes21"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FLR_USD_ID",
      "outputs": [
        {
          "internalType": "bytes21",
          "name": "",
          "type": "bytes21"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "checkAndEndRound",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endLottery",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "enterLottery",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "forceEndRound",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fundLottery",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isRoundActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lotteryEndTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lotteryThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "participantBalances",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "participants",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "roundId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newEndTime",
          "type": "uint256"
        }
      ],
      "name": "setLotteryEndTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newThreshold",
          "type": "uint256"
        }
      ],
      "name": "setLotteryThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "startRound",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFunds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
  "receipt": {
    "to": null,
    "from": "0x81194315767d0524470ae715ca0284fC061C1e60",
    "contractAddress": "0x0e06e51ABB2E402be0e108E50D20005EF2Ea89F3",
    "transactionIndex": 0,
    "gasUsed": "801246",
    "logsBloom": "0x00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000400000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43",
    "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x000000000000000000000000c738fdcde9cd2fbd72618d36ed71008b8d001ba4000000000000000000000000000000000000000000000000000000000000421a",
        "logIndex": 0,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x000000000000000000000000d2a1bb23eb350814a30dd6f9de78bb2c8fdd9f1d000000000000000000000000000000000000000000000000000000000000fe24",
        "logIndex": 1,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x0000000000000000000000006892bdbbb14e1c9bd46bf31e7bac94d038fc82a6000000000000000000000000000000000000000000000000000000000000422d",
        "logIndex": 2,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x000000000000000000000000bd33bdff04c357f7fc019e72d0504c24cf4aa0100000000000000000000000000000000000000000000000000000000000008688",
        "logIndex": 3,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x000000000000000000000000a90db6d10f856799b10ef2a77ebcbf460ac71e5200000000000000000000000000000000000000000000000000000000000024f3",
        "logIndex": 4,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 17224160,
        "transactionHash": "0x325062134dce8046ab9b128979be9e3fd4a3e9877349c04a78b0122cf96349f6",
        "address": "0x1000000000000000000000000000000000000002",
        "topics": [
          "0xe7aa66356adbd5e839ef210626f6d8f6f72109c17fadf4c4f9ca82b315ae79b4"
        ],
        "data": "0x0000000000000000000000000b162ca3acf3482d3357972e12d794434085d839000000000000000000000000000000000000000000000000000000000001687e",
        "logIndex": 5,
        "blockHash": "0x515c1384978ec5b6c8d0dedf9951dbcaf5aa58b74476cc0d7bfc80f8a7c16b43"
      }
    ],
    "blockNumber": 17224160,
    "cumulativeGasUsed": "801246",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 10,
  "solcInputHash": "b9a3e54b34ae5823e02223e827a2965d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LotteryEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"LotteryStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BTC_USD_ID\",\"outputs\":[{\"internalType\":\"bytes21\",\"name\":\"\",\"type\":\"bytes21\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_USD_ID\",\"outputs\":[{\"internalType\":\"bytes21\",\"name\":\"\",\"type\":\"bytes21\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLR_USD_ID\",\"outputs\":[{\"internalType\":\"bytes21\",\"name\":\"\",\"type\":\"bytes21\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkAndEndRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterLottery\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceEndRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundLottery\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRoundActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participantBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newEndTime\",\"type\":\"uint256\"}],\"name\":\"setLotteryEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setLotteryThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/VolatilityLottery.sol\":\"VolatilityLottery\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\n\\n// Auto generated imports\\n// AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\nimport {IPriceSubmitter} from \\\"./IPriceSubmitter.sol\\\";\\nimport {IGovernanceSettings} from \\\"./IGovernanceSettings.sol\\\";\\nimport {IFtsoRewardManager} from \\\"./IFtsoRewardManager.sol\\\";\\nimport {IFtsoRegistry} from \\\"./IFtsoRegistry.sol\\\";\\nimport {IVoterWhitelister} from \\\"./IVoterWhitelister.sol\\\";\\nimport {IDistributionToDelegators} from \\\"./IDistributionToDelegators.sol\\\";\\nimport {IFtsoManager} from \\\"./IFtsoManager.sol\\\";\\nimport {IWNat} from \\\"./IWNat.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IClaimSetupManager} from \\\"./IClaimSetupManager.sol\\\";\\nimport {IGenericRewardManager} from \\\"./IGenericRewardManager.sol\\\";\\nimport {IFlareAssetRegistry} from \\\"./IFlareAssetRegistry.sol\\\";\\nimport {IValidatorRegistry} from \\\"./IValidatorRegistry.sol\\\";\\nimport {IFlareContractRegistry} from \\\"./IFlareContractRegistry.sol\\\";\\nimport {IAddressBinder} from \\\"./IAddressBinder.sol\\\";\\nimport {IPChainStakeMirror} from \\\"./IPChainStakeMirror.sol\\\";\\nimport {IPChainStakeMirrorVerifier} from \\\"./IPChainStakeMirrorVerifier.sol\\\";\\nimport {IPChainStakeMirrorMultiSigVoting} from \\\"./IPChainStakeMirrorMultiSigVoting.sol\\\";\\nimport {ISubmission} from \\\"./ISubmission.sol\\\";\\nimport {IEntityManager} from \\\"./IEntityManager.sol\\\";\\nimport {IVoterRegistry} from \\\"./IVoterRegistry.sol\\\";\\nimport {IFlareSystemsCalculator} from \\\"./IFlareSystemsCalculator.sol\\\";\\nimport {IFlareSystemsManager} from \\\"./IFlareSystemsManager.sol\\\";\\nimport {IRewardManager} from \\\"./IRewardManager.sol\\\";\\nimport {IRelay} from \\\"./IRelay.sol\\\";\\nimport {IWNatDelegationFee} from \\\"./IWNatDelegationFee.sol\\\";\\nimport {IFtsoInflationConfigurations} from \\\"./IFtsoInflationConfigurations.sol\\\";\\nimport {IFtsoRewardOffersManager} from \\\"./IFtsoRewardOffersManager.sol\\\";\\nimport {IFtsoFeedDecimals} from \\\"./IFtsoFeedDecimals.sol\\\";\\nimport {IFtsoFeedPublisher} from \\\"./IFtsoFeedPublisher.sol\\\";\\nimport {IFtsoFeedIdConverter} from \\\"./IFtsoFeedIdConverter.sol\\\";\\nimport {IFastUpdateIncentiveManager} from \\\"./IFastUpdateIncentiveManager.sol\\\";\\nimport {IFastUpdater} from \\\"./IFastUpdater.sol\\\";\\nimport {IFastUpdatesConfiguration} from \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport {IRNat} from \\\"./IRNat.sol\\\";\\nimport {IFeeCalculator} from \\\"./IFeeCalculator.sol\\\";\\nimport {FtsoV2Interface} from \\\"./FtsoV2Interface.sol\\\";\\nimport {TestFtsoV2Interface} from \\\"./TestFtsoV2Interface.sol\\\";\\nimport {ProtocolsV2Interface} from \\\"./ProtocolsV2Interface.sol\\\";\\nimport {RandomNumberV2Interface} from \\\"./RandomNumberV2Interface.sol\\\";\\nimport {RewardsV2Interface} from \\\"./RewardsV2Interface.sol\\\";\\nimport {IFdcVerification} from \\\"./IFdcVerification.sol\\\";\\nimport {IFdcHub} from \\\"./IFdcHub.sol\\\";\\nimport {IFdcRequestFeeConfigurations} from \\\"./IFdcRequestFeeConfigurations.sol\\\";\\nimport {IJsonApiVerification} from \\\"./IJsonApiVerification.sol\\\";\\n// END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n\\n// Library is intended to be used inline, so the strings are all memory allocated (instead of calldata)\\nlibrary ContractRegistry {\\n    address internal constant FLARE_CONTRACT_REGISTRY_ADDRESS =\\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\\n\\n    IFlareContractRegistry internal constant FLARE_CONTRACT_REGISTRY =\\n        IFlareContractRegistry(FLARE_CONTRACT_REGISTRY_ADDRESS);\\n\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(\\n        string memory _name\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByName(_name);\\n    }\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(\\n        bytes32 _nameHash\\n    ) internal view returns (address) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByHash(_nameHash);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(\\n        string[] memory _names\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByName(_names);\\n    }\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(\\n        bytes32[] memory _nameHashes\\n    ) internal view returns (address[] memory) {\\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByHash(_nameHashes);\\n    }\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts()\\n        internal\\n        view\\n        returns (string[] memory _names, address[] memory _addresses)\\n    {\\n        return FLARE_CONTRACT_REGISTRY.getAllContracts();\\n    }\\n\\n    // Nice typed getters for all the important contracts\\n    // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\\n    function getPriceSubmitter() internal view returns (IPriceSubmitter) {\\n        return\\n            IPriceSubmitter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PriceSubmitter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceSettings()\\n        internal\\n        view\\n        returns (IGovernanceSettings)\\n    {\\n        return\\n            IGovernanceSettings(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceSettings\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardManager() internal view returns (IFtsoRewardManager) {\\n        return\\n            IFtsoRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRegistry() internal view returns (IFtsoRegistry) {\\n        return\\n            IFtsoRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterWhitelister() internal view returns (IVoterWhitelister) {\\n        return\\n            IVoterWhitelister(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterWhitelister\\\"))\\n                )\\n            );\\n    }\\n\\n    function getDistributionToDelegators()\\n        internal\\n        view\\n        returns (IDistributionToDelegators)\\n    {\\n        return\\n            IDistributionToDelegators(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"DistributionToDelegators\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoManager() internal view returns (IFtsoManager) {\\n        return\\n            IFtsoManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNat() internal view returns (IWNat) {\\n        return\\n            IWNat(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNat\\\"))\\n                )\\n            );\\n    }\\n\\n    function getGovernanceVotePower()\\n        internal\\n        view\\n        returns (IGovernanceVotePower)\\n    {\\n        return\\n            IGovernanceVotePower(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"GovernanceVotePower\\\"))\\n                )\\n            );\\n    }\\n\\n    function getClaimSetupManager() internal view returns (IClaimSetupManager) {\\n        return\\n            IClaimSetupManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ClaimSetupManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getValidatorRewardManager()\\n        internal\\n        view\\n        returns (IGenericRewardManager)\\n    {\\n        return\\n            IGenericRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ValidatorRewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareAssetRegistry()\\n        internal\\n        view\\n        returns (IFlareAssetRegistry)\\n    {\\n        return\\n            IFlareAssetRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareAssetRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getValidatorRegistry() internal view returns (IValidatorRegistry) {\\n        return\\n            IValidatorRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ValidatorRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareContractRegistry()\\n        internal\\n        view\\n        returns (IFlareContractRegistry)\\n    {\\n        return\\n            IFlareContractRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareContractRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getAddressBinder() internal view returns (IAddressBinder) {\\n        return\\n            IAddressBinder(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"AddressBinder\\\"))\\n                )\\n            );\\n    }\\n\\n    function getPChainStakeMirror() internal view returns (IPChainStakeMirror) {\\n        return\\n            IPChainStakeMirror(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PChainStakeMirror\\\"))\\n                )\\n            );\\n    }\\n\\n    function getPChainStakeMirrorVerifier()\\n        internal\\n        view\\n        returns (IPChainStakeMirrorVerifier)\\n    {\\n        return\\n            IPChainStakeMirrorVerifier(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PChainStakeMirrorVerifier\\\"))\\n                )\\n            );\\n    }\\n\\n    function getPChainStakeMirrorMultiSigVoting()\\n        internal\\n        view\\n        returns (IPChainStakeMirrorMultiSigVoting)\\n    {\\n        return\\n            IPChainStakeMirrorMultiSigVoting(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"PChainStakeMirrorMultiSigVoting\\\"))\\n                )\\n            );\\n    }\\n\\n    function getSubmission() internal view returns (ISubmission) {\\n        return\\n            ISubmission(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Submission\\\"))\\n                )\\n            );\\n    }\\n\\n    function getEntityManager() internal view returns (IEntityManager) {\\n        return\\n            IEntityManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"EntityManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getVoterRegistry() internal view returns (IVoterRegistry) {\\n        return\\n            IVoterRegistry(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"VoterRegistry\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsCalculator()\\n        internal\\n        view\\n        returns (IFlareSystemsCalculator)\\n    {\\n        return\\n            IFlareSystemsCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFlareSystemsManager()\\n        internal\\n        view\\n        returns (IFlareSystemsManager)\\n    {\\n        return\\n            IFlareSystemsManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FlareSystemsManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardManager() internal view returns (IRewardManager) {\\n        return\\n            IRewardManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRelay() internal view returns (IRelay) {\\n        return\\n            IRelay(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"Relay\\\"))\\n                )\\n            );\\n    }\\n\\n    function getWNatDelegationFee() internal view returns (IWNatDelegationFee) {\\n        return\\n            IWNatDelegationFee(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"WNatDelegationFee\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoInflationConfigurations()\\n        internal\\n        view\\n        returns (IFtsoInflationConfigurations)\\n    {\\n        return\\n            IFtsoInflationConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoInflationConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoRewardOffersManager()\\n        internal\\n        view\\n        returns (IFtsoRewardOffersManager)\\n    {\\n        return\\n            IFtsoRewardOffersManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoRewardOffersManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedDecimals() internal view returns (IFtsoFeedDecimals) {\\n        return\\n            IFtsoFeedDecimals(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedDecimals\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedPublisher() internal view returns (IFtsoFeedPublisher) {\\n        return\\n            IFtsoFeedPublisher(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedPublisher\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoFeedIdConverter()\\n        internal\\n        view\\n        returns (IFtsoFeedIdConverter)\\n    {\\n        return\\n            IFtsoFeedIdConverter(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoFeedIdConverter\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdateIncentiveManager()\\n        internal\\n        view\\n        returns (IFastUpdateIncentiveManager)\\n    {\\n        return\\n            IFastUpdateIncentiveManager(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdateIncentiveManager\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdater() internal view returns (IFastUpdater) {\\n        return\\n            IFastUpdater(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdater\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFastUpdatesConfiguration()\\n        internal\\n        view\\n        returns (IFastUpdatesConfiguration)\\n    {\\n        return\\n            IFastUpdatesConfiguration(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FastUpdatesConfiguration\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRNat() internal view returns (IRNat) {\\n        return\\n            IRNat(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RNat\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFeeCalculator() internal view returns (IFeeCalculator) {\\n        return\\n            IFeeCalculator(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FeeCalculator\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFtsoV2() internal view returns (FtsoV2Interface) {\\n        return\\n            FtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getTestFtsoV2() internal view returns (TestFtsoV2Interface) {\\n        return\\n            TestFtsoV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FtsoV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getProtocolsV2() internal view returns (ProtocolsV2Interface) {\\n        return\\n            ProtocolsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"ProtocolsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRandomNumberV2()\\n        internal\\n        view\\n        returns (RandomNumberV2Interface)\\n    {\\n        return\\n            RandomNumberV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RandomNumberV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getRewardsV2() internal view returns (RewardsV2Interface) {\\n        return\\n            RewardsV2Interface(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"RewardsV2\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcVerification() internal view returns (IFdcVerification) {\\n        return\\n            IFdcVerification(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcVerification\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcHub() internal view returns (IFdcHub) {\\n        return\\n            IFdcHub(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcHub\\\"))\\n                )\\n            );\\n    }\\n\\n    function getFdcRequestFeeConfigurations()\\n        internal\\n        view\\n        returns (IFdcRequestFeeConfigurations)\\n    {\\n        return\\n            IFdcRequestFeeConfigurations(\\n                FLARE_CONTRACT_REGISTRY.getContractAddressByHash(\\n                    keccak256(abi.encode(\\\"FdcRequestFeeConfigurations\\\"))\\n                )\\n            );\\n    }\\n\\n    // Returns hardcoded unofficial deployment instances of Flare core contracts\\n    function auxiliaryGetIJsonApiVerification()\\n        internal\\n        pure\\n        returns (IJsonApiVerification)\\n    {\\n        return IJsonApiVerification(0x07ad8508C9173DC845817472Ca0484035AbFA3c8);\\n    }\\n\\n    // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\\n}\\n\",\"keccak256\":\"0x7bd0556f06aed4bdfca7d76827676aa537d7d0ae0f10c91719169ceadb1601be\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface FtsoV2Interface {\\n\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds() external view returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges() external view returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(bytes21 _feedId) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(bytes21[] memory _feedIds) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(bytes21 _feedId)\\n        external payable\\n        returns (\\n            uint256 _value,\\n            int8 _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(bytes21[] memory _feedIds)\\n        external payable\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(bytes21 _feedId)\\n        external payable\\n        returns (\\n            uint256 _value,\\n            uint64 _timestamp\\n        );\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(bytes21[] memory _feedIds)\\n        external payable\\n        returns (\\n            uint256[] memory _values,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(FeedDataWithProof calldata _feedData) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8297aa8c798f265999dba83e3c5eb45478a0d28c21c3640570d548699e306541\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressBinder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for the `AddressBinder` contract.\\n */\\ninterface IAddressBinder {\\n\\n    /**\\n     * @notice Event emitted when c-chan and P-chain addresses are registered\\n     */\\n    event AddressesRegistered(bytes publicKey, bytes20 pAddress, address cAddress);\\n\\n    /**\\n     * Register P-chain and C-chain addresses.\\n     * @param _publicKey Public key from which addresses to register are derived from.\\n     * @param _pAddress P-chain address to register.\\n     * @param _cAddress C-chain address to register.\\n     */\\n    function registerAddresses(bytes calldata _publicKey, bytes20 _pAddress, address _cAddress) external;\\n\\n    /**\\n     * Register P-chain and C-chain addresses derived from given public key.\\n     * @param _publicKey Public key from which addresses to register are derived from.\\n     * @return _pAddress Registered P-chain address.\\n     * @return _cAddress Registered C-chain address.\\n     */\\n    function registerPublicKey(bytes calldata _publicKey) external returns(bytes20 _pAddress, address _cAddress);\\n\\n    /**\\n     * @dev Queries the C-chain address for given P-chain address.\\n     * @param _pAddress The P-chain address for which corresponding C-chain address will be retrieved.\\n     * @return _cAddress The corresponding c-address.\\n     **/\\n    function pAddressToCAddress(bytes20 _pAddress) external view returns(address _cAddress);\\n\\n    /**\\n     * @dev Queries the P-chain address for given C-chain address.\\n     * @param _cAddress The C-chain address for which corresponding P-chain address will be retrieved.\\n     * @return _pAddress The corresponding p-address.\\n     **/\\n    function cAddressToPAddress(address _cAddress) external view returns(bytes20 _pAddress);\\n}\",\"keccak256\":\"0x34e8aa7f1a415862829786a80888406926ef3cccf5435baea322182df86f227a\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IAddressValidity\\n * @custom:id 0x05\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion whether a string represents a valid address on an external chain.\\n * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.\\n * Indicator of validity is provided.\\n * If the address is valid, its standard form and standard hash are computed.\\n * Validity criteria for each supported chain:\\n * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)\\n * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)\\n * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)\\n * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)\\n * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`\\n */\\ninterface IAddressValidity {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId Id of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IAddressValidity attestation type\\n     * @param addressStr Address to be verified.\\n     */\\n    struct RequestBody {\\n        string addressStr;\\n    }\\n\\n    /**\\n     * @notice Response body for IAddressValidity attestation type\\n     * @param isValid Boolean indicator of the address validity.\\n     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.\\n     * @param standardAddressHash If `isValid`, standard address hash of the validated address.\\n     * Otherwise a zero bytes32 string.\\n     */\\n    struct ResponseBody {\\n        bool isValid;\\n        string standardAddress;\\n        bytes32 standardAddressHash;\\n    }\\n}\\n\",\"keccak256\":\"0x5dfa0afc7251c6db95b2303acb9e7d917187ba614eb330d642bd6d639cbbce72\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IAddressValidityVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IAddressValidity.sol\\\";\\n\\ninterface IAddressValidityVerification {\\n\\n    function verifyAddressValidity(IAddressValidity.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x99e73ae149411fceacdc0a8d4bb9d9adc222e3df5430205d11f073b12c3b3bbf\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IBalanceDecreasingTransaction\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A detection of a transaction that either decreases the balance for some address or is\\n * signed by the source address.\\n * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate\\n * some funds locked by a smart contract on Flare.\\n *\\n * A transaction is considered \\u201cbalance decreasing\\u201d for the address, if the balance after the\\n * transaction is lower than before or the address is among the signers of the transaction\\n * (even if its balance is greater than before the transaction).\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the\\n * source blockchain node or relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a\\n * sufficient number of confirmations, the attestation request is rejected.\\n *\\n * Once the transaction is received, the response fields are extracted if the transaction is balance\\n * decreasing for the indicated address.\\n * Some of the request and response fields are chain specific as described below.\\n * The fields can be computed with the help of a balance decreasing summary.\\n *\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.\\n * If the indicated input does not exist or the indicated input does not have the address,\\n * the attestation request is rejected.\\n * The `sourceAddress` is the address of the indicated transaction input.\\n * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of\\n * all outputs with `sourceAddress`.\\n * Can be negative.\\n * - `blockTimestamp` is the mediantime of a block.\\n *\\n * ### XRPL\\n *\\n * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.\\n * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance\\n * of the address was not lowered in the transaction, the attestation request is rejected.\\n *\\n * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.\\n * Can be negative.\\n * - `blockTimestamp` is the close_time of a ledger converted to unix time.\\n *\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IBalanceDecreasingTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * This is a security measure to prevent a collision of attestation hashes.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for IBalanceDecreasingTransaction attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        bytes32 sourceAddressIndicator;\\n    }\\n\\n    /**\\n     * @notice Response body for IBalanceDecreasingTransaction attestation type.\\n     * @param blockNumber The number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.\\n     * @param spentAmount Amount spent by the source address in minimal units.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        int256 spentAmount;\\n        bytes32 standardPaymentReference;\\n    }\\n}\\n\",\"keccak256\":\"0x2981047bbc558613e917f4a421ac6f1ac6b1b404c57451f141ad8a4bf5121743\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IBalanceDecreasingTransaction.sol\\\";\\n\\ninterface IBalanceDecreasingTransactionVerification {\\n    function verifyBalanceDecreasingTransaction(IBalanceDecreasingTransaction.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x7e40674a6bd78394ecc69349853ef9be63ad81d375478ed3aa6ac4ea931948f7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IBn256.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n// G1Point implements a point in G1 group.\\nstruct G1Point {\\n  uint256 x;\\n  uint256 y;\\n}\\n\",\"keccak256\":\"0xd04c3b6f729dbe78f57526de2b58510c4e906810dadf5836ba0715e4d60fe6f0\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IClaimSetupManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IDelegationAccount.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IClaimSetupManager {\\n\\n    event DelegationAccountCreated(address owner, IDelegationAccount delegationAccount);\\n    event DelegationAccountUpdated(address owner, IDelegationAccount delegationAccount, bool enabled);\\n    event ClaimExecutorsChanged(address owner, address[] executors);\\n    event AllowedClaimRecipientsChanged(address owner, address[] recipients);\\n    event ClaimExecutorFeeValueChanged(address executor, uint256 validFromRewardEpoch, uint256 feeValueWei);\\n    event ExecutorRegistered(address executor);\\n    event ExecutorUnregistered(address executor, uint256 validFromRewardEpoch);\\n    event MinFeeSet(uint256 minFeeValueWei);\\n    event MaxFeeSet(uint256 maxFeeValueWei);\\n    event RegisterExecutorFeeSet(uint256 registerExecutorFeeValueWei);\\n    event SetExecutorsExcessAmountRefunded(address owner, uint256 excessAmount);\\n\\n    /**\\n     * @notice Sets the addresses of executors and optionally enables (creates) delegation account.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setAutoClaiming(address[] memory _executors, bool _enableDelegationAccount) external payable;\\n\\n    /**\\n     * @notice Sets the addresses of executors.\\n     * @notice If setting registered executors some fee must be paid to them.\\n     * @param _executors        The new executors. All old executors will be deleted and replaced by these.\\n     */ \\n    function setClaimExecutors(address[] memory _executors) external payable;\\n\\n    /**\\n     * Set the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */    \\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Enables (creates) delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to delegation account when using automatic claiming.\\n     * @return Address of delegation account contract.\\n     */\\n    function enableDelegationAccount() external returns (IDelegationAccount);\\n\\n    /**\\n     * @notice Disables delegation account contract,\\n     * i.e. all airdrop and ftso rewards will be send to owner's account when using automatic claiming.\\n     * @notice Automatic claiming will not claim airdrop and ftso rewards for delegation account anymore.\\n     * @dev Reverts if there is no delegation account\\n     */\\n    function disableDelegationAccount() external;\\n\\n    /**\\n     * @notice Allows executor to register and set initial fee value.\\n     * If executor was already registered before (has fee set), only update fee after `feeValueUpdateOffset`.\\n     * @notice Executor must pay fee in order to register - `registerExecutorFeeValueWei`.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function registerExecutor(uint256 _feeValue) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows executor to unregister.\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function unregisterExecutor() external returns (uint256);\\n\\n    /**\\n     * @notice Allows registered executor to set (or update last scheduled) fee value.\\n     * @param _feeValue    number representing fee value\\n     * @return Returns the reward epoch number when the setting becomes effective.\\n     */\\n    function updateExecutorFeeValue(uint256 _feeValue) external returns(uint256);\\n\\n    /**\\n     * @notice Delegate `_bips` of voting power to `_to` from msg.sender's delegation account\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     */\\n    function delegate(address _to, uint256 _bips) external;\\n\\n    /**\\n     * @notice Undelegate all percentage delegations from the msg.sender's delegation account and then delegate \\n     *   corresponding `_bips` percentage of voting power to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     */\\n    function batchDelegate(address[] memory _delegatees, uint256[] memory _bips) external;\\n\\n    /**\\n     * @notice Undelegate all voting power for delegates of msg.sender's delegation account\\n     */\\n    function undelegateAll() external;\\n\\n    /**\\n     * @notice Revoke all delegation from msg.sender's delegation account to `_who` at given block. \\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past. \\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate with value of 0 or undelegateAll.\\n     */\\n    function revokeDelegationAt(address _who, uint256 _blockNumber) external;\\n\\n    /**\\n     * @notice Delegate all governance vote power of msg.sender's delegation account to `_to`.\\n     * @param _to The address of the recipient\\n     */\\n    function delegateGovernance(address _to) external;\\n\\n    /**\\n     * @notice Undelegate governance vote power for delegate of msg.sender's delegation account\\n     */\\n    function undelegateGovernance() external;\\n\\n    /**\\n     * @notice Allows user to transfer WNat to owner's account.\\n     * @param _amount           Amount of tokens to transfer\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     * @notice Allows user to transfer balance of ERC20 tokens owned by the personal delegation contract.\\n     The main use case is to transfer tokens/NFTs that were received as part of an airdrop or register \\n     as participant in such airdrop.\\n     * @param _token            Target token contract address\\n     * @param _amount           Amount of tokens to transfer\\n     * @dev Reverts if target token is WNat contract - use method `withdraw` for that\\n     */\\n    function transferExternalToken(IERC20 _token, uint256 _amount) external;\\n\\n    /**\\n     * @notice Gets the delegation account of the `_owner`. Returns address(0) if not created yet.\\n     */\\n    function accountToDelegationAccount(address _owner) external view returns (address);\\n\\n    /**\\n     * @notice Gets the delegation account data for the `_owner`. Returns address(0) if not created yet.\\n     * @param _owner                        owner's address\\n     * @return _delegationAccount           owner's delegation account address - could be address(0)\\n     * @return _enabled                     indicates if delegation account is enabled\\n     */\\n    function getDelegationAccountData(\\n        address _owner\\n    )\\n        external view\\n        returns (IDelegationAccount _delegationAccount, bool _enabled);\\n\\n    /**\\n     * @notice Get the addresses of executors.\\n     */    \\n    function claimExecutors(address _owner) external view returns (address[] memory);\\n\\n    /**\\n     * Get the addresses of allowed recipients.\\n     * Apart from these, the owner is always an allowed recipient.\\n     */    \\n    function allowedClaimRecipients(address _rewardOwner) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns info if `_executor` is allowed to execute calls for `_owner`\\n     */\\n    function isClaimExecutor(address _owner, address _executor) external view returns(bool);\\n\\n    /**\\n     * @notice Get registered executors\\n     */\\n    function getRegisteredExecutors(\\n        uint256 _start, \\n        uint256 _end\\n    ) \\n        external view\\n        returns (address[] memory _registeredExecutors, uint256 _totalLength);\\n\\n    /**\\n     * @notice Returns some info about the `_executor`\\n     * @param _executor             address representing executor\\n     * @return _registered          information if executor is registered\\n     * @return _currentFeeValue     executor's current fee value\\n     */\\n    function getExecutorInfo(address _executor) external view returns (bool _registered, uint256 _currentFeeValue);\\n\\n    /**\\n     * @notice Returns the current fee value of `_executor`\\n     * @param _executor             address representing executor\\n     */\\n    function getExecutorCurrentFeeValue(address _executor) external view  returns (uint256);\\n\\n    /**\\n     * @notice Returns the fee value of `_executor` at `_rewardEpoch`\\n     * @param _executor             address representing executor\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getExecutorFeeValue(address _executor, uint256 _rewardEpoch) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the scheduled fee value changes of `_executor`\\n     * @param _executor             address representing executor\\n     * @return _feeValue            positional array of fee values\\n     * @return _validFromEpoch      positional array of reward epochs the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getExecutorScheduledFeeValueChanges(address _executor)\\n        external view\\n        returns (\\n            uint256[] memory _feeValue,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"keccak256\":\"0x7f3411de9e68f4da6b5bd81e0eb75e58b3cdb8efa8564ca8da85499573e9ba82\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExists.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IConfirmedBlockHeightExists\\n * @custom:id 0x02\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice An assertion that a block with `blockNumber` is confirmed.\\n * It also provides data to compute the block production rate in the given time range.\\n * @custom:verification It is checked that the block with `blockNumber` is confirmed by at\\n * least `numberOfConfirmations`.\\n * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.\\n * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.\\n *\\n *\\n * Current confirmation heights consensus:\\n *\\n *\\n * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |\\n * | ------- | --------- | ----------------------- | ------------ |\\n * | `BTC`   | 0         | 6                       | mediantime   |\\n * | `DOGE`  | 2         | 60                      | mediantime   |\\n * | `XRP`   | 3         | 3                       | close_time   |\\n *\\n *\\n * @custom:lut `lowestQueryWindowBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IConfirmedBlockHeightExists {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the\\n     * response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ConfirmedBlockHeightExistsType attestation type\\n     * @param blockNumber The number of the block the request wants a confirmation of.\\n     * @param queryWindow The length of the period in which the block production rate is to be computed.\\n     */\\n    struct RequestBody {\\n        uint64 blockNumber;\\n        uint64 queryWindow;\\n    }\\n\\n    /**\\n     * @notice Response body for ConfirmedBlockHeightExistsType attestation type\\n     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`\\n     * can be used to compute the average block production time in the specified block range.\\n     * @param blockTimestamp The timestamp of the block with `blockNumber`.\\n     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.\\n     * All attestation providers must agree on this number.\\n     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller\\n     * than `blockTimestamp` - `queryWindow`.\\n     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 blockTimestamp;\\n        uint64 numberOfConfirmations;\\n        uint64 lowestQueryWindowBlockNumber;\\n        uint64 lowestQueryWindowBlockTimestamp;\\n    }\\n}\\n\",\"keccak256\":\"0xedc37a6a835438a8bd33f628afc0bfa8963bc5558cf7c3aa693f12cf867ce587\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExistsVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IConfirmedBlockHeightExists.sol\\\";\\n\\ninterface IConfirmedBlockHeightExistsVerification {\\n    function verifyConfirmedBlockHeightExists(IConfirmedBlockHeightExists.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x1e0ae9a5adacad1abf8479e1b894109b1a7c9b95d44497baecfa1be994d29f13\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IDelegationAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IClaimSetupManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDelegationAccount {\\n\\n    event DelegateFtso(address to, uint256 bips);\\n    event RevokeFtso(address to, uint256 blockNumber);\\n    event UndelegateAllFtso();\\n    event DelegateGovernance(address to);\\n    event UndelegateGovernance();\\n    event WithdrawToOwner(uint256 amount);\\n    event ExternalTokenTransferred(IERC20 token, uint256 amount);\\n    event ExecutorFeePaid(address executor, uint256 amount);\\n    event Initialize(address owner, IClaimSetupManager manager);\\n}\\n\",\"keccak256\":\"0xcf15c36971de85a142e931378fef2e2145231420f88d725502e2d3b69a40845f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IDistributionToDelegators.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IDistributionToDelegators {\\n    // Events\\n    event UseGoodRandomSet(bool useGoodRandom, uint256 maxWaitForGoodRandomSeconds);\\n    event EntitlementStart(uint256 entitlementStartTs);\\n    event AccountClaimed(address indexed whoClaimed, address indexed sentTo, uint256 month, uint256 amountWei);\\n    event AccountOptOut(address indexed theAccount, bool confirmed);\\n\\n\\n    // Methods\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _month                last month to claim for\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     */\\n    function claim(address _rewardOwner, address _recipient, uint256 _month, bool _wrap)\\n        external returns(uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows batch claiming for the list of '_rewardOwners' up to given '_month'.\\n     * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and\\n     *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.\\n     * @notice Claimed amount is automatically wrapped.\\n     * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,\\n     *   then fee is paid to executor for each claimed address from the list.\\n     * @param _rewardOwners         list of reward owners to claim for\\n     * @param _month                last month to claim for\\n     */\\n    function autoClaim(address[] calldata _rewardOwners, uint256 _month) external;\\n    \\n    /**\\n     * @notice Method to opt-out of receiving airdrop rewards\\n     */\\n    function optOutOfAirdrop() external;\\n    \\n    /**\\n     * @notice Returns the next claimable month for '_rewardOwner'.\\n     * @param _rewardOwner          address of the reward owner\\n     */\\n    function nextClaimableMonth(address _rewardOwner) external view returns (uint256);\\n\\n    /**\\n     * @notice get claimable amount of wei for requesting account for specified month\\n     * @param _month month of interest\\n     * @return _amountWei amount of wei available for this account and provided month\\n     */\\n    function getClaimableAmount(uint256 _month) external view returns(uint256 _amountWei);\\n\\n    /**\\n     * @notice get claimable amount of wei for account for specified month\\n     * @param _account the address of an account we want to get the claimable amount of wei\\n     * @param _month month of interest\\n     * @return _amountWei amount of wei available for provided account and month\\n     */\\n    function getClaimableAmountOf(address _account, uint256 _month) external view returns(uint256 _amountWei);\\n\\n    /**\\n     * @notice Returns the current month\\n     * @return _currentMonth Current month, 0 before entitlementStartTs\\n     */\\n    function getCurrentMonth() external view returns (uint256 _currentMonth);\\n\\n    /**\\n     * @notice Returns the month that will expire next\\n     * @return _monthToExpireNext Month that will expire next, 1100 when last month expired\\n     */\\n    function getMonthToExpireNext() external view returns (uint256 _monthToExpireNext);\\n\\n    /**\\n     * @notice Returns claimable months - reverts if none\\n     * @return _startMonth first claimable month\\n     * @return _endMonth last claimable month\\n     */\\n    function getClaimableMonths() external view returns(uint256 _startMonth, uint256 _endMonth);\\n}\\n\",\"keccak256\":\"0x57673c17e802148dafc7137c212e6308e5a6836fc708dc168f66a488ab309261\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IEVMTransaction\\n * @custom:id 0x06\\n * @custom:supported ETH, FLR, SGB\\n * @author Flare\\n * @notice A relay of a transaction from an EVM chain.\\n * This type is only relevant for EVM-compatible chains.\\n * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with\\n * at least `requiredConfirmations`, the specified data is relayed.\\n * If an indicated event does not exist, the request is rejected.\\n * @custom:lut `timestamp`\\n * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`\\n */\\ninterface IEVMTransaction {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is\\n     * determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for EVM transaction attestation type\\n     * @custom:below Note that events (logs) are indexed in block not in each transaction.\\n     * The contract that uses the attestation should specify the order of event logs as needed and the requestor should\\n     * sort `logIndices` with respect to the set specifications.\\n     * If possible, the contact should require one `logIndex`.\\n     * @param transactionHash Hash of the transaction(transactionHash).\\n     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.\\n     * @param provideInput If true, \\\"input\\\" field is included in the response.\\n     * @param listEvents If true, events indicated by `logIndices` are included in the response.\\n     * Otherwise, no events are included in the response.\\n     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,\\n     * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)\\n     * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.\\n     * If empty, it indicates all events in order capped by 50.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionHash;\\n        uint16 requiredConfirmations;\\n        bool provideInput;\\n        bool listEvents;\\n        uint32[] logIndices;\\n    }\\n\\n    /**\\n     * @notice Response body for EVM transaction attestation type\\n     * @custom:below The fields are in line with transaction provided by EVM node.\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param timestamp Timestamp of the block in which the transaction is included.\\n     * @param sourceAddress The address (from) that signed the transaction.\\n     * @param isDeployment Indicate whether it is a contract creation transaction.\\n     * @param receivingAddress The address (to) of the receiver of the initial transaction.\\n     * Zero address if `isDeployment` is `true`.\\n     * @param value The value transferred by the initial transaction in wei.\\n     * @param input If `provideInput`, this is the data send along with the initial transaction.\\n     * Otherwise it is the default value `0x00`.\\n     * @param status Status of the transaction 1 - success, 0 - failure.\\n     * @param events If `listEvents` is `true`, an array of the requested events.\\n     * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 timestamp;\\n        address sourceAddress;\\n        bool isDeployment;\\n        address receivingAddress;\\n        uint256 value;\\n        bytes input;\\n        uint8 status;\\n        Event[] events;\\n    }\\n\\n    /**\\n     * @notice Event log record\\n     * @custom:above An `Event` is a struct with the following fields:\\n     * @custom:below The fields are in line with EVM event logs.\\n     * @param logIndex The consecutive number of the event in block.\\n     * @param emitterAddress The address of the contract that emitted the event.\\n     * @param topics An array of up to four 32-byte strings of indexed log arguments.\\n     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.\\n     * @param removed It is `true` if the log was removed due to a chain reorganization\\n     * and `false` if it is a valid log.\\n     */\\n    struct Event {\\n        uint32 logIndex;\\n        address emitterAddress;\\n        bytes32[] topics;\\n        bytes data;\\n        bool removed;\\n    }\\n}\\n\",\"keccak256\":\"0x12c4709d09d96c4c24816e01e57e82ecd7910a486dcda9e07a53f7f37a7219c3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEVMTransactionVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IEVMTransaction.sol\\\";\\n\\ninterface IEVMTransactionVerification {\\n\\n    function verifyEVMTransaction(IEVMTransaction.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0xda9dd04e9a222d68a3f8afd1d67193aecc02efef0d0d324529e119fd218edd47\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IEntityManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * EntityManager interface.\\n */\\ninterface IEntityManager {\\n\\n    /// Voter addresses.\\n    struct VoterAddresses {\\n        address submitAddress;\\n        address submitSignaturesAddress;\\n        address signingPolicyAddress;\\n    }\\n\\n    /// Event emitted when a node id is registered.\\n    event NodeIdRegistered(\\n        address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a node id is unregistered.\\n    event NodeIdUnregistered(\\n        address indexed voter, bytes20 indexed nodeId);\\n    /// Event emitted when a public key is registered.\\n    event PublicKeyRegistered(\\n        address indexed voter, bytes32 indexed part1, bytes32 indexed part2);\\n    /// Event emitted when a public key is unregistered.\\n    event PublicKeyUnregistered(\\n        address indexed voter, bytes32 indexed part1, bytes32 indexed part2);\\n    /// Event emitted when a delegation address is proposed.\\n    event DelegationAddressProposed(\\n        address indexed voter, address indexed delegationAddress);\\n    /// Event emitted when a delegation address registration is confirmed.\\n    event DelegationAddressRegistrationConfirmed(\\n        address indexed voter, address indexed delegationAddress);\\n    /// Event emitted when a submit address is proposed.\\n    event SubmitAddressProposed(\\n        address indexed voter, address indexed submitAddress);\\n    /// Event emitted when a submit address registration is confirmed.\\n    event SubmitAddressRegistrationConfirmed(\\n        address indexed voter, address indexed submitAddress);\\n    /// Event emitted when a submit signatures address is proposed.\\n    event SubmitSignaturesAddressProposed(\\n        address indexed voter, address indexed submitSignaturesAddress);\\n    /// Event emitted when a submit signatures address registration is confirmed.\\n    event SubmitSignaturesAddressRegistrationConfirmed(\\n        address indexed voter, address indexed submitSignaturesAddress);\\n    /// Event emitted when a signing policy address is proposed.\\n    event SigningPolicyAddressProposed(\\n        address indexed voter, address indexed signingPolicyAddress);\\n    /// Event emitted when a signing policy address registration is confirmed.\\n    event SigningPolicyAddressRegistrationConfirmed(\\n        address indexed voter, address indexed signingPolicyAddress);\\n    /// Event emitted when the maximum number of node ids per entity is set.\\n    event MaxNodeIdsPerEntitySet(\\n        uint256 maxNodeIdsPerEntity);\\n\\n    /**\\n     * Registers a node id.\\n     * @param _nodeId Node id.\\n     * @param _certificateRaw Certificate in raw format.\\n     * @param _signature Signature.\\n     */\\n    function registerNodeId(bytes20 _nodeId, bytes calldata _certificateRaw, bytes calldata _signature) external;\\n\\n    /**\\n     * Unregisters a node id.\\n     * @param _nodeId Node id.\\n     */\\n    function unregisterNodeId(bytes20 _nodeId) external;\\n\\n    /**\\n     * Registers a public key.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _verificationData Additional data used to verify the public key.\\n     */\\n    function registerPublicKey(bytes32 _part1, bytes32 _part2, bytes calldata _verificationData) external;\\n\\n    /**\\n     * Unregisters a public key.\\n     */\\n    function unregisterPublicKey() external;\\n\\n    /**\\n     * Proposes a delegation address (called by the voter).\\n     * @param _delegationAddress Delegation address.\\n     */\\n    function proposeDelegationAddress(address _delegationAddress) external;\\n\\n    /**\\n     * Confirms a delegation address registration (called by the delegation address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmDelegationAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit address (called by the voter).\\n     * @param _submitAddress Submit address.\\n     */\\n    function proposeSubmitAddress(address _submitAddress) external;\\n\\n    /**\\n     * Confirms a submit address registration (called by the submit address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a submit signatures address (called by the voter).\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     */\\n    function proposeSubmitSignaturesAddress(address _submitSignaturesAddress) external;\\n\\n    /**\\n     * Confirms a submit signatures address registration (called by the submit signatures address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSubmitSignaturesAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Proposes a signing policy address (called by the voter).\\n     * @param _signingPolicyAddress Signing policy address.\\n     */\\n    function proposeSigningPolicyAddress(address _signingPolicyAddress) external;\\n\\n    /**\\n     * Confirms a signing policy address registration (called by the signing policy address).\\n     * @param _voter Voter address.\\n     */\\n    function confirmSigningPolicyAddressRegistration(address _voter) external;\\n\\n    /**\\n     * Gets the delegation address of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOfAt(address _voter, uint256 _blockNumber) external view returns(address);\\n\\n    /**\\n     * Gets the delegation address of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getDelegationAddressOf(address _voter) external view returns(address);\\n\\n    /**\\n     * Gets the node ids of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOfAt(address _voter, uint256 _blockNumber) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the node ids of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Node ids.\\n     */\\n    function getNodeIdsOf(address _voter) external view returns (bytes20[] memory);\\n\\n    /**\\n     * Gets the public key of a voter at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOfAt(address _voter, uint256 _blockNumber) external view returns(bytes32, bytes32);\\n\\n    /**\\n     * Gets the public key of a voter at the current block number.\\n     * @param _voter Voter address.\\n     * @return Public key.\\n     */\\n    function getPublicKeyOf(address _voter) external view returns(bytes32, bytes32);\\n\\n    /**\\n     * Gets voter's addresses at a specific block number.\\n     * @param _voter Voter address.\\n     * @param _blockNumber Block number.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddressesAt(address _voter, uint256 _blockNumber)\\n        external view\\n        returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's addresses at the current block number.\\n     * @param _voter Voter address.\\n     * @return _addresses Voter addresses.\\n     */\\n    function getVoterAddresses(address _voter)\\n        external view\\n        returns (VoterAddresses memory _addresses);\\n\\n    /**\\n     * Gets voter's address for a node id at a specific block number.\\n     * @param _nodeId Node id.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForNodeId(bytes20 _nodeId, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a public key at a specific block number.\\n     * @param _part1 First part of the public key.\\n     * @param _part2 Second part of the public key.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForPublicKey(bytes32 _part1, bytes32 _part2, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a delegation address at a specific block number.\\n     * @param _delegationAddress Delegation address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForDelegationAddress(address _delegationAddress, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit address at a specific block number.\\n     * @param _submitAddress Submit address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitAddress(address _submitAddress, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a submit signatures address at a specific block number.\\n     * @param _submitSignaturesAddress Submit signatures address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSubmitSignaturesAddress(address _submitSignaturesAddress, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n\\n    /**\\n     * Gets voter's address for a signing policy address at a specific block number.\\n     * @param _signingPolicyAddress Signing policy address.\\n     * @param _blockNumber Block number.\\n     * @return _voter Voter address.\\n     */\\n    function getVoterForSigningPolicyAddress(address _signingPolicyAddress, uint256 _blockNumber)\\n        external view\\n        returns (address _voter);\\n}\\n\",\"keccak256\":\"0xe6fc7a09236a714fee0b9beea6676b5bdc084560a1c5250b1b6dfd5a83d029c7\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdateIncentiveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFixedPointArithmetic.sol\\\" as FPA;\\nimport \\\"./IFastUpdatesConfiguration.sol\\\";\\nimport \\\"./IIncreaseManager.sol\\\";\\n\\n/**\\n * Fast update incentive manager interface.\\n */\\ninterface IFastUpdateIncentiveManager is IIncreaseManager {\\n\\n    /// Incentive offer structure.\\n    struct IncentiveOffer {\\n        FPA.Range rangeIncrease;\\n        FPA.Range rangeLimit;\\n    }\\n\\n    /// Event emitted when an incentive is offered.\\n    event IncentiveOffered(\\n        uint24 indexed rewardEpochId,\\n        FPA.Range rangeIncrease,\\n        FPA.SampleSize sampleSizeIncrease,\\n        FPA.Fee offerAmount\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed configurations\\n        IFastUpdatesConfiguration.FeedConfiguration[] feedConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * The entry point for third parties to make incentive offers. It accepts a payment and, using the contents of\\n     * `_offer`, computes how much the expected sample size will be increased to apply the requested (but capped) range\\n     * increase. If the ultimate value of the range exceeds the cap, funds are returned to the sender in proportion to\\n     * the amount by which the increase is adjusted to reach the cap.\\n     * @param _offer The requested amount of per-block variation range increase,\\n     * along with a cap for the ultimate range.\\n     */\\n    function offerIncentive(IncentiveOffer calldata _offer) external payable;\\n\\n    /// Viewer for the current value of the expected sample size.\\n    function getExpectedSampleSize() external view returns (FPA.SampleSize);\\n\\n    /// Viewer for the current value of the unit delta's precision (the fractional part of the scale).\\n    function getPrecision() external view returns (FPA.Precision);\\n\\n    /// Viewer for the current value of the per-block variation range.\\n    function getRange() external view returns (FPA.Range);\\n\\n    /// Viewer for the current value of sample size increase price.\\n    function getCurrentSampleSizeIncreasePrice() external view returns (FPA.Fee);\\n\\n    /// Viewer for the current value of the scale itself.\\n    function getScale() external view returns (FPA.Scale);\\n\\n    /// Viewer for the base value of the scale itself.\\n    function getBaseScale() external view returns (FPA.Scale);\\n\\n    /// The maximum amount by which the expected sample size can be increased by an incentive offer.\\n    /// This is controlled by governance and forces a minimum cost to increasing the sample size greatly,\\n    /// which would otherwise be an attack on the protocol.\\n    function sampleIncreaseLimit() external view returns (FPA.SampleSize);\\n\\n    /// The maximum value that the range can be increased to by an incentive offer.\\n    function rangeIncreaseLimit() external view returns (FPA.Range);\\n\\n    /// The price for increasing the per-block range of variation by 1, prorated for the actual amount of increase.\\n    function rangeIncreasePrice() external view returns (FPA.Fee);\\n}\\n\",\"keccak256\":\"0x54902290268700e5feee26896b85c8adf63e4ec740a57abbfa17bafbe30d4d76\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdater.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\nimport { SortitionCredential } from \\\"./ISortition.sol\\\";\\n\\n/**\\n * Fast updater interface.\\n */\\ninterface IFastUpdater {\\n\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Fast update structure\\n    struct FastUpdates {\\n        uint256 sortitionBlock;\\n        SortitionCredential sortitionCredential;\\n        bytes deltas;\\n        Signature signature;\\n    }\\n\\n    /// Event emitted when a new set of updates is submitted.\\n    event FastUpdateFeedsSubmitted(\\n        uint32 indexed votingRoundId,\\n        address indexed signingPolicyAddress\\n    );\\n\\n    /// Event emitted when a feed is added or reset.\\n    event FastUpdateFeedReset(\\n        uint256 indexed votingRoundId,\\n        uint256 indexed index,\\n        bytes21 indexed id,\\n        uint256 value,\\n        int8 decimals);\\n\\n    /// Event emitted when a feed is removed.\\n    event FastUpdateFeedRemoved(\\n        uint256 indexed index);\\n\\n    /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.\\n    event FastUpdateFeeds(uint256 indexed votingEpochId, uint256[] feeds, int8[] decimals);\\n\\n    /**\\n     * The entry point for providers to submit an update transaction.\\n     * @param _updates Data of an update transaction, which in addition to the actual list of updates,\\n     * includes the sortition credential proving the provider's eligibility to make updates in the also-included\\n     * sortition round, as well as a signature allowing a single registered provider to submit from multiple\\n     * EVM accounts.\\n     */\\n    function submitUpdates(FastUpdates calldata _updates) external;\\n\\n    /**\\n     * Public access to the stored data of all feeds.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @return _feedIds The list of feed ids.\\n     * @return _feeds The list of feeds.\\n     * @return _decimals The list of decimal places for feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchAllCurrentFeeds()\\n        external payable\\n        returns (\\n            bytes21[] memory _feedIds,\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.\\n     * Feeds should be sorted for better performance.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in\\n     * the `FastUpdatesConfiguration` contract.\\n     * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given\\n     * (which may not be their sorted order).\\n     * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were\\n     * given (which may not be their sorted order).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function fetchCurrentFeeds(\\n        uint256[] calldata _indices\\n    )\\n        external payable\\n        returns (\\n            uint256[] memory _feeds,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function currentScoreCutoff() external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.\\n     * @param _blockNum The block for which the cutoff is requested.\\n     * @return _cutoff The upper endpoint of the acceptable range of \\\"scores\\\" that providers generate for sortition.\\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\\n     */\\n    function blockScoreCutoff(uint256 _blockNum) external view returns (uint256 _cutoff);\\n\\n    /**\\n     * Informational getter concerning a provider's likelihood of being chosen by sortition.\\n     * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the\\n     * sender of an update transaction, due to the signature included in the `FastUpdates` type.\\n     * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's\\n     * delegation weight for the FTSO, but rescaled against a fixed number of \\\"virtual providers\\\", indicating how many\\n     * potential updates a single provider may make in a sortition round.\\n     */\\n    function currentSortitionWeight(address _signingPolicyAddress) external view returns (uint256 _weight);\\n\\n    /**\\n     * The submission window is a number of blocks forming a \\\"grace period\\\" after a round of sortition starts,\\n     * during which providers may submit updates for that round. In other words, each block starts a new round of\\n     * sortition and that round lasts `submissionWindow` blocks.\\n     */\\n    function submissionWindow() external view returns (uint8);\\n\\n    /**\\n     * Id of the current reward epoch.\\n     */\\n    function currentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).\\n     * @param _historySize The number of blocks for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.\\n     * The array is ordered from the current block to the oldest block.\\n     */\\n    function numberOfUpdates(uint256 _historySize) external view returns (uint256[] memory _noOfUpdates);\\n\\n    /**\\n     * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.\\n     * @param _blockNumber The block number for which the number of updates should be returned.\\n     * @return _noOfUpdates The number of updates submitted in the specified block.\\n     */\\n    function numberOfUpdatesInBlock(uint256 _blockNumber) external view returns (uint256 _noOfUpdates);\\n}\\n\",\"keccak256\":\"0x3686a45d54ded58b4350421c6b74f10c328be61351e86d2d0e9c7cc51b3470c5\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFastUpdatesConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FastUpdatesConfiguration interface.\\n */\\ninterface IFastUpdatesConfiguration {\\n\\n    /**\\n     * The feed configuration struct.\\n     */\\n    struct FeedConfiguration {\\n        // feed id\\n        bytes21 feedId;\\n        // reward band value (interpreted off-chain) in relation to the median\\n        uint32 rewardBandValue;\\n        // inflation share\\n        uint24 inflationShare;\\n    }\\n\\n    /// Event emitted when a feed is added.\\n    event FeedAdded(bytes21 indexed feedId, uint32 rewardBandValue, uint24 inflationShare, uint256 index);\\n    /// Event emitted when a feed is updated.\\n    event FeedUpdated(bytes21 indexed feedId, uint32 rewardBandValue, uint24 inflationShare, uint256 index);\\n    /// Event emitted when a feed is removed.\\n    event FeedRemoved(bytes21 indexed feedId, uint256 index);\\n\\n    /**\\n     * Returns the index of a feed.\\n     * @param _feedId The feed id.\\n     * @return _index The index of the feed.\\n     */\\n    function getFeedIndex(bytes21 _feedId) external view returns (uint256 _index);\\n\\n    /**\\n     * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).\\n     * @param _index The index.\\n     * @return _feedId The feed id.\\n     */\\n    function getFeedId(uint256 _index) external view returns (bytes21 _feedId);\\n\\n    /**\\n     * Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).\\n     */\\n    function getFeedIds() external view returns (bytes21[] memory);\\n\\n    /**\\n     * Returns the number of feeds, including removed ones.\\n     */\\n    function getNumberOfFeeds() external view returns (uint256);\\n\\n    /**\\n     * Returns the feed configurations, including removed ones.\\n     */\\n    function getFeedConfigurations() external view returns (FeedConfiguration[] memory);\\n\\n    /**\\n     * Returns the unused indices - indices of removed feeds.\\n     */\\n    function getUnusedIndices() external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x52f88f75d59f6e065354af8f6843a51155a6304797788559bfeea25d66e27778\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcHub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFdcInflationConfigurations.sol\\\";\\nimport \\\"./IFdcRequestFeeConfigurations.sol\\\";\\n\\n\\n/**\\n * FdcHub interface.\\n */\\ninterface IFdcHub  {\\n\\n    // Event emitted when an attestation request is made.\\n    event AttestationRequest(bytes data, uint256 fee);\\n\\n    // Event emitted when a requests offset is set.\\n    event RequestsOffsetSet(uint8 requestsOffsetSeconds);\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // fdc configurations\\n        IFdcInflationConfigurations.FdcConfiguration[] fdcConfigurations,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount\\n    );\\n\\n    /**\\n     * Method to request an attestation.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function requestAttestation(bytes calldata _data) external payable;\\n\\n    /**\\n     * The offset (in seconds) for the requests to be processed during the current voting round.\\n     */\\n    function requestsOffsetSeconds() external view returns (uint8);\\n\\n    /**\\n     * The FDC inflation configurations contract.\\n     */\\n    function fdcInflationConfigurations() external view returns(IFdcInflationConfigurations);\\n\\n    /**\\n     * The FDC request fee configurations contract.\\n     */\\n    function fdcRequestFeeConfigurations() external view returns (IFdcRequestFeeConfigurations);\\n}\\n\",\"keccak256\":\"0xc5da8a1ec45a746ce6a7dcba8010cf2e422e42992d219bc4c46314884b1d888f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * FdcInflationConfigurations interface.\\n */\\ninterface IFdcInflationConfigurations {\\n\\n    /// The FDC configuration struct.\\n\\n    struct FdcConfiguration {\\n        // attestation type\\n        bytes32 attestationType;\\n        // source\\n        bytes32 source;\\n        // inflation share for this configuration\\n        uint24 inflationShare;\\n        // minimal reward eligibility threshold in number of request\\n        uint8 minRequestsThreshold;\\n        // mode (additional settings interpreted on the client side off-chain)\\n        uint224 mode;\\n    }\\n\\n    /**\\n     * Returns the FDC configuration at `_index`.\\n     * @param _index The index of the FDC configuration.\\n     */\\n    function getFdcConfiguration(uint256 _index) external view returns(FdcConfiguration memory);\\n\\n    /**\\n     * Returns the FDC configurations.\\n     */\\n    function getFdcConfigurations() external view returns(FdcConfiguration[] memory);\\n}\\n\",\"keccak256\":\"0xa63ac03178c776d3909ae0ce2272de2d199e162804b30cd90dea470c026bfbac\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcRequestFeeConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * FdcRequestFeeConfigurations interface.\\n */\\ninterface IFdcRequestFeeConfigurations  {\\n\\n    // Event emitted when a type and source price is set.\\n    event TypeAndSourceFeeSet(bytes32 indexed attestationType, bytes32 indexed source, uint256 fee);\\n\\n    // Event emitted when a type and source price is removed.\\n    event TypeAndSourceFeeRemoved(bytes32 indexed attestationType, bytes32 indexed source);\\n\\n    /**\\n     * Method to get the base fee for an attestation request. It reverts if the request is not supported.\\n     * @param _data ABI encoded attestation request\\n     */\\n    function getRequestFee(bytes calldata _data) external view returns (uint256);\\n\\n}\\n\",\"keccak256\":\"0x1a7b44a0a5419173ade6906f51ab645bd18cb5b48b49f288bc353580f72e1da8\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IAddressValidityVerification.sol\\\";\\nimport \\\"./IBalanceDecreasingTransactionVerification.sol\\\";\\nimport \\\"./IConfirmedBlockHeightExistsVerification.sol\\\";\\nimport \\\"./IEVMTransactionVerification.sol\\\";\\nimport \\\"./IPaymentVerification.sol\\\";\\nimport \\\"./IReferencedPaymentNonexistenceVerification.sol\\\";\\nimport \\\"./IWeb2JsonVerification.sol\\\";\\n\\n\\n/**\\n * FdcVerification interface.\\n */\\ninterface IFdcVerification is\\n    IAddressValidityVerification,\\n    IBalanceDecreasingTransactionVerification,\\n    IConfirmedBlockHeightExistsVerification,\\n    IEVMTransactionVerification,\\n    IPaymentVerification,\\n    IReferencedPaymentNonexistenceVerification,\\n    IWeb2JsonVerification\\n{ }\\n\",\"keccak256\":\"0xfda51f805d6abac0cb3eab3bdfd95fb13eb6d9febea5e4a36971d1c36e6e0f6a\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFeeCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * FeeCalculator interface.\\n */\\ninterface IFeeCalculator {\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _feedIds List of feed ids.\\n    */\\n    function calculateFeeByIds(bytes21[] memory _feedIds) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates a fee that needs to be paid to fetch feeds' data.\\n     * @param _indices Indices of the feeds, corresponding to feed ids in\\n     * the FastUpdatesConfiguration contract.\\n    */\\n    function calculateFeeByIndices(uint256[] memory _indices) external view returns (uint256 _fee);\\n}\\n\\n\",\"keccak256\":\"0xbe04e98db0852b02a99b10f7ab50a34cb28c712562d50a8ebb3a3de6a3a361a6\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFixedPointArithmetic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/*\\n * Opaque type synonyms to enforce arithemtic correctness.\\n * All of these are internally uint256 to avert solc's restricted-bit-size internal handling.\\n * Since the space is available, the fractional parts of all (except Price,\\n * which is not controlled by us) are very wide.\\n */\\n\\ntype Scale is uint256;      // 1x127\\ntype Precision is uint256;  // 0x127; the fractional part of Scale, top bit always 0\\ntype SampleSize is uint256; // 8x120; current gas usage and block gas limit force <32 update transactions per block\\ntype Range is uint256;      // 8x120, with some space for >100% fluctuations\\n                            // (measured volatility per block is ~1e-3 at most)\\ntype Fractional is uint256; // 0x128\\n\\ntype Fee is uint256;        // 128x0; same scale as currency units,restricted to bottom 128 bits\\n                            // (1e18 integer and fractional parts) to accommodate arithmetic\\n\",\"keccak256\":\"0x654f39a367efcda750dfa931070b828fe4c3498678dc75c46f4f9f366df58b0d\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareAssetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\n\\ninterface IFlareAssetRegistry {\\n\\n    /**\\n     * @notice Returns if the token is a Flare Asset\\n     * @dev All other methods that accept token address will fail if this method returns false\\n     * @param token The token to be checked\\n     */\\n    function isFlareAsset(address token) external view returns (bool);\\n\\n    /**\\n     * Return the asset type of the token. Asset type is a hash uniquely identifying the asset type.\\n     * For example, for wrapped native token, the type is `keccak256(\\\"wrapped native\\\")`,\\n     * and for all f-assets the type will be `keccak256(\\\"f-asset\\\")`.\\n     */\\n    function assetType(address _token) external view returns (bytes32);\\n    \\n     /**\\n     * @notice Returns the address of the Flare Asset with the selected symbol\\n     * @param symbol The token's symbol\\n     */\\n    function assetBySymbol(string calldata symbol) external view returns (address);\\n\\n    /**\\n     * @notice Returns if the Flare Asset supports delegation via IVPToken interface\\n     * @param token The token to be checked\\n     */\\n    function supportsFtsoDelegation(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the maximum allowed number of delegates by percent for the selected token\\n     * @param token The token to be checked\\n     */\\n    function maxDelegatesByPercent(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the incentive pool address for the selected token\\n     * @param token The token to be checked\\n     */\\n    function incentivePoolFor(address token) external view returns (address);\\n\\n    /**\\n     * @notice Returns the addresses of all Flare Assets\\n     */\\n    function allAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets\\n     */\\n    function allAssetsWithSymbols() external view returns (address[] memory, string[] memory);\\n\\n    /**\\n     * @notice Returns all asset types.\\n     */\\n    function allAssetTypes() external view returns (bytes32[] memory);\\n        \\n    /**\\n     * @notice Returns the addresses of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfType(bytes32 _assetType) external view returns (address[] memory);\\n    \\n    /**\\n     * @notice Returns the addresses and associated symbols of all Flare Assets of given type.\\n     * @param _assetType a type hash, all returned assets will have this assetType\\n     */\\n    function allAssetsOfTypeWithSymbols(bytes32 _assetType) external view returns (address[] memory, string[] memory);\\n\\n     /**\\n     * @notice Returns a generic asset attribute value.\\n     * @param token The token's address\\n     * @param nameHash attributes name's hash\\n     * @return defined true if the attribute is defined for this token\\n     * @return value attribute value, may have to be cast into some other type\\n     */\\n    function getAttribute(address token, bytes32 nameHash) external view returns (bool defined, bytes32 value);\\n}\\n\",\"keccak256\":\"0x201ba0945239bc603f4486e52bab29a3044918f31af0f169de17f9b6ba33c836\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareContractRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\ninterface IFlareContractRegistry {\\n    /**\\n     * @notice Returns contract address for the given name - might be address(0)\\n     * @param _name             name of the contract\\n     */\\n    function getContractAddressByName(string calldata _name) external view returns(address);\\n\\n    /**\\n     * @notice Returns contract address for the given name hash - might be address(0)\\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressByHash(bytes32 _nameHash) external view returns(address);\\n\\n    /**\\n     * @notice Returns contract addresses for the given names - might be address(0)\\n     * @param _names            names of the contracts\\n     */\\n    function getContractAddressesByName(string[] calldata _names) external view returns(address[] memory);\\n\\n    /**\\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\\n     */\\n    function getContractAddressesByHash(bytes32[] calldata _nameHashes) external view returns(address[] memory);\\n\\n    /**\\n     * @notice Returns all contract names and corresponding addresses\\n     */\\n    function getAllContracts() external view returns(string[] memory _names, address[] memory _addresses);\\n}\\n\",\"keccak256\":\"0x358aa3eced2172a3c252cd0c5efeb2572969ac6b64001f62facf185193668cea\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * FlareSystemsCalculator interface.\\n */\\ninterface IFlareSystemsCalculator {\\n\\n    /// Event emitted when the registration weight of a voter is calculated.\\n    event VoterRegistrationInfo(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address delegationAddress,\\n        uint16 delegationFeeBIPS,\\n        uint256 wNatWeight,\\n        uint256 wNatCappedWeight,\\n        bytes20[] nodeIds,\\n        uint256[] nodeWeights\\n    );\\n\\n    /// WNat cap used in signing policy weight.\\n    function wNatCapPPM() external view returns (uint24);\\n    /// Non-punishable time to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationSeconds() external view returns (uint64);\\n    /// Number of non-punishable blocks to sign new signing policy.\\n    function signingPolicySignNonPunishableDurationBlocks() external view returns (uint64);\\n    /// Number of blocks (in addition to non-punishable blocks) after which all rewards are burned.\\n    function signingPolicySignNoRewardsDurationBlocks() external view returns (uint64);\\n\\n}\\n\",\"keccak256\":\"0x6016f1d289f3b9fc8ba68ed8bb4f5f3018c92a900dc6d69270c3b6ab6f37c00f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ProtocolsV2Interface.sol\\\";\\n\\n/**\\n * FlareSystemsManager interface.\\n */\\ninterface IFlareSystemsManager is ProtocolsV2Interface {\\n\\n    /// Signature structure\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Number of weight based claims structure\\n    struct NumberOfWeightBasedClaims {\\n        uint256 rewardManagerId;\\n        uint256 noOfWeightBasedClaims;\\n    }\\n\\n    /// Event emitted when random acquisition phase starts.\\n    event RandomAcquisitionStarted(\\n        uint24 indexed rewardEpochId,   // Reward epoch id\\n        uint64 timestamp                // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when vote power block is selected.\\n    event VotePowerBlockSelected(\\n        uint24 indexed rewardEpochId,   // Reward epoch id\\n        uint64 votePowerBlock,          // Vote power block for given reward epoch\\n        uint64 timestamp                // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when signing policy is signed.\\n    event SigningPolicySigned(\\n        uint24 indexed rewardEpochId,           // Reward epoch id\\n        address indexed signingPolicyAddress,   // Address which signed this\\n        address indexed voter,                  // Voter (entity)\\n        uint64 timestamp,                       // Timestamp when this happened\\n        bool thresholdReached                   // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when reward epoch starts.\\n    event RewardEpochStarted(\\n        uint24 indexed rewardEpochId,   // Reward epoch id\\n        uint32 startVotingRoundId,      // First voting round id of validity\\n        uint64 timestamp                // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when it is time to sign uptime vote.\\n    event SignUptimeVoteEnabled(\\n        uint24 indexed rewardEpochId,   // Reward epoch id\\n        uint64 timestamp                // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is submitted.\\n    event UptimeVoteSubmitted(\\n        uint24 indexed rewardEpochId,           // Reward epoch id\\n        address indexed signingPolicyAddress,   // Address which signed this\\n        address indexed voter,                  // Voter (entity)\\n        bytes20[] nodeIds,                      // Node ids with high enough uptime\\n        uint64 timestamp                        // Timestamp when this happened\\n    );\\n\\n    /// Event emitted when uptime vote is signed.\\n    event UptimeVoteSigned(\\n        uint24 indexed rewardEpochId,           // Reward epoch id\\n        address indexed signingPolicyAddress,   // Address which signed this\\n        address indexed voter,                  // Voter (entity)\\n        bytes32 uptimeVoteHash,                 // Uptime vote hash\\n        uint64 timestamp,                       // Timestamp when this happened\\n        bool thresholdReached                   // Indicates if signing threshold was reached\\n    );\\n\\n    /// Event emitted when rewards are signed.\\n    event RewardsSigned(\\n        uint24 indexed rewardEpochId,                       // Reward epoch id\\n        address indexed signingPolicyAddress,               // Address which signed this\\n        address indexed voter,                              // Voter (entity)\\n        bytes32 rewardsHash,                                // Rewards hash\\n        NumberOfWeightBasedClaims[] noOfWeightBasedClaims,  // Number of weight based claims list\\n        uint64 timestamp,                                   // Timestamp when this happened\\n        bool thresholdReached                               // Indicates if signing threshold was reached\\n    );\\n\\n    /**\\n     * Method for collecting signatures for the new signing policy.\\n     * @param _rewardEpochId Reward epoch id of the new signing policy.\\n     * @param _newSigningPolicyHash New signing policy hash.\\n     * @param _signature Signature.\\n     */\\n    function signNewSigningPolicy(\\n        uint24 _rewardEpochId,\\n        bytes32 _newSigningPolicyHash,\\n        Signature calldata _signature\\n    )\\n        external;\\n\\n    /**\\n     * Method for submitting node ids with high enough uptime.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _nodeIds Node ids with high enough uptime.\\n     * @param _signature Signature.\\n     */\\n    function submitUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes20[] calldata _nodeIds,\\n        Signature calldata _signature\\n    )\\n        external;\\n\\n    /**\\n     * Method for collecting signatures for the uptime vote.\\n     * @param _rewardEpochId Reward epoch id of the uptime vote.\\n     * @param _uptimeVoteHash Uptime vote hash.\\n     * @param _signature Signature.\\n     */\\n    function signUptimeVote(\\n        uint24 _rewardEpochId,\\n        bytes32 _uptimeVoteHash,\\n        Signature calldata _signature\\n    )\\n        external;\\n\\n    /**\\n     * Method for collecting signatures for the rewards.\\n     * @param _rewardEpochId Reward epoch id of the rewards.\\n     * @param _noOfWeightBasedClaims Number of weight based claims list.\\n     * @param _rewardsHash Rewards hash.\\n     * @param _signature Signature.\\n     */\\n    function signRewards(\\n        uint24 _rewardEpochId,\\n        NumberOfWeightBasedClaims[] calldata _noOfWeightBasedClaims,\\n        bytes32 _rewardsHash,\\n        Signature calldata _signature\\n    )\\n        external;\\n\\n    /**\\n     * Returns the seed for given reward epoch id.\\n     */\\n    function getSeed(uint256 _rewardEpochId)\\n        external view\\n        returns(uint256);\\n\\n    /**\\n     * Returns the threshold for given reward epoch id.\\n     */\\n    function getThreshold(uint256 _rewardEpochId)\\n        external view\\n        returns(uint16);\\n\\n    /**\\n     * Returns voter rgistration data for given reward epoch id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _votePowerBlock Vote power block.\\n     * @return _enabled Indicates if voter registration is enabled.\\n     */\\n    function getVoterRegistrationData(\\n        uint256 _rewardEpochId\\n    )\\n        external view\\n        returns (\\n            uint256 _votePowerBlock,\\n            bool _enabled\\n        );\\n\\n    /**\\n     * Indicates if voter registration is currently enabled.\\n     */\\n    function isVoterRegistrationEnabled() external view returns (bool);\\n\\n    /**\\n     * Returns the current reward epoch id (backwards compatibility).\\n     */\\n    function getCurrentRewardEpoch() external view returns(uint256);\\n}\\n\",\"keccak256\":\"0x0b781fcf8d9e114ccf04df2dee3169ebdc6bbf37f2d1a4585ed712c9ef3169f2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtso {\\n    enum PriceFinalizationType {\\n        // initial state\\n        NOT_FINALIZED,\\n        // median calculation used to find price\\n        WEIGHTED_MEDIAN,\\n        // low turnout - price calculated from median of trusted addresses\\n        TRUSTED_ADDRESSES,\\n        // low turnout + no votes from trusted addresses - price copied from previous epoch\\n        PREVIOUS_PRICE_COPIED,\\n        // price calculated from median of trusted addresses - triggered due to an exception\\n        TRUSTED_ADDRESSES_EXCEPTION,\\n        // previous price copied - triggered due to an exception\\n        PREVIOUS_PRICE_COPIED_EXCEPTION\\n    }\\n\\n    event PriceRevealed(\\n        address indexed voter, uint256 indexed epochId, uint256 price, uint256 timestamp,\\n        uint256 votePowerNat, uint256 votePowerAsset\\n    );\\n\\n    event PriceFinalized(\\n        uint256 indexed epochId, uint256 price, bool rewardedFtso,\\n        uint256 lowIQRRewardPrice, uint256 highIQRRewardPrice,\\n        uint256 lowElasticBandRewardPrice, uint256 highElasticBandRewardPrice, \\n        PriceFinalizationType finalizationType, uint256 timestamp\\n    );\\n\\n    event PriceEpochInitializedOnFtso(\\n        uint256 indexed epochId, uint256 endTime, uint256 timestamp\\n    );\\n\\n    event LowTurnout(\\n        uint256 indexed epochId,\\n        uint256 natTurnout,\\n        uint256 lowNatTurnoutThresholdBIPS,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Returns if FTSO is active\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the FTSO symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns current epoch id\\n     */\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns id of the epoch which was opened for price submission at the specified timestamp\\n     * @param _timestamp            Timestamp as seconds from unix epoch\\n     */\\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\\n    \\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns asset price consented in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPrice(uint256 _epochId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _epochId                 Current epoch id\\n     * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch\\n     * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch\\n     * @return _votePowerBlock          Vote power block for the current epoch\\n     * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used\\n     * @dev half-closed intervals - end time not included\\n     */\\n    function getPriceEpochData() external view returns (\\n        uint256 _epochId,\\n        uint256 _epochSubmitEndTime,\\n        uint256 _epochRevealEndTime,\\n        uint256 _votePowerBlock,\\n        bool _fallbackMode\\n    );\\n\\n    /**\\n     * @notice Returns current epoch data\\n     * @return _firstEpochStartTs           First epoch start timestamp\\n     * @return _submitPeriodSeconds         Submit period in seconds\\n     * @return _revealPeriodSeconds         Reveal period in seconds\\n     */\\n    function getPriceEpochConfiguration() external view returns (\\n        uint256 _firstEpochStartTs,\\n        uint256 _submitPeriodSeconds,\\n        uint256 _revealPeriodSeconds\\n    );\\n    \\n    /**\\n     * @notice Returns asset price submitted by voter in specific epoch\\n     * @param _epochId              Id of the epoch\\n     * @param _voter                Address of the voter\\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     */\\n    function getEpochPriceForVoter(uint256 _epochId, address _voter) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns current asset price\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPrice() external view returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimals() external view returns (\\n        uint256 _price,\\n        uint256 _timestamp,\\n        uint256 _assetPriceUsdDecimals\\n    );\\n    \\n    /**\\n     * @notice Returns current asset price calculated from trusted providers\\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp           Time when price was updated for the last time\\n     */\\n    function getCurrentPriceFromTrustedProviders() external view returns (uint256 _price, uint256 _timestamp);\\n\\n    /**\\n     * @notice Returns current asset price calculated from trusted providers and number of decimals\\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _timestamp               Time when price was updated for the last time\\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\\n     */\\n    function getCurrentPriceWithDecimalsFromTrustedProviders() external view returns (\\n        uint256 _price,\\n        uint256 _timestamp,\\n        uint256 _assetPriceUsdDecimals\\n    );\\n\\n    /**\\n     * @notice Returns current asset price details\\n     * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\\n     * @return _priceTimestamp                          Time when price was updated for the last time\\n     * @return _priceFinalizationType                   Finalization type when price was updated for the last time\\n     * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized\\n     * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch\\n     */\\n    function getCurrentPriceDetails() external view returns (\\n        uint256 _price,\\n        uint256 _priceTimestamp,\\n        PriceFinalizationType _priceFinalizationType,\\n        uint256 _lastPriceEpochFinalizationTimestamp,\\n        PriceFinalizationType _lastPriceEpochFinalizationType\\n    );\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfae54442fb489dccc5f0a0a6f8d946c9fdebceece98fcb087c5998fa1363ff30\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedDecimals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedDecimals interface.\\n */\\ninterface IFtsoFeedDecimals {\\n\\n    /// Event emitted when a feed decimals value is changed.\\n    event DecimalsChanged(bytes21 indexed feedId, int8 decimals, uint24 rewardEpochId);\\n\\n    /// The offset in reward epochs for the decimals value to become effective.\\n    function decimalsUpdateOffset() external view returns (uint24);\\n\\n    /// The default decimals value.\\n    function defaultDecimals() external view returns (int8);\\n\\n    /**\\n     * Returns current decimals set for `_feedId`.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentDecimals(bytes21 _feedId) external view returns (int8);\\n\\n    /**\\n     * Returns the decimals of `_feedId` for given reward epoch id.\\n     * @param _feedId Feed id.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimals(\\n        bytes21 _feedId,\\n        uint256 _rewardEpochId\\n    )\\n        external view\\n        returns (int8);\\n\\n    /**\\n     * Returns the scheduled decimals changes of `_feedId`.\\n     * @param _feedId Feed id.\\n     * @return _decimals Positional array of decimals.\\n     * @return _validFromEpochId Positional array of reward epoch ids the decimals settings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getScheduledDecimalsChanges(\\n        bytes21 _feedId\\n    )\\n        external view\\n        returns (\\n            int8[] memory _decimals,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * Returns current decimals setting for `_feedIds`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     */\\n    function getCurrentDecimalsBulk(\\n        bytes memory _feedIds\\n    )\\n        external view\\n        returns (bytes memory _decimals);\\n\\n    /**\\n     * Returns decimals setting for `_feedIds` at `_rewardEpochId`.\\n     * @param _feedIds Concatenated feed ids (each feedId bytes21).\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).\\n     * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.\\n     */\\n    function getDecimalsBulk(\\n        bytes memory _feedIds,\\n        uint256 _rewardEpochId\\n    )\\n        external view\\n        returns (bytes memory _decimals);\\n}\\n\",\"keccak256\":\"0x71cd95c6f51b7b56e93654e8ef720fec354e1a41aed3582c9c54943db154c4b8\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedIdConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * IFtsoFeedIdConverter interface.\\n */\\ninterface IFtsoFeedIdConverter {\\n\\n    /**\\n     * Returns the feed id for given category and name.\\n     * @param _category Feed category.\\n     * @param _name Feed name.\\n     * @return Feed id.\\n     */\\n    function getFeedId(uint8 _category, string memory _name) external view returns(bytes21);\\n\\n    /**\\n     * Returns the feed category and name for given feed id.\\n     * @param _feedId Feed id.\\n     * @return _category Feed category.\\n     * @return _name Feed name.\\n     */\\n    function getFeedCategoryAndName(bytes21 _feedId) external pure returns(uint8 _category, string memory _name);\\n}\\n\",\"keccak256\":\"0x00485da13e69da70486701d5aedc6cab4b0c16820fef36586c08383b2ab17c32\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedPublisher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoFeedPublisher interface.\\n */\\ninterface IFtsoFeedPublisher {\\n\\n    /// The FTSO feed struct.\\n    struct Feed {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// The FTSO random struct.\\n    struct Random {\\n        uint32 votingRoundId;\\n        uint256 value;\\n        bool isSecure;\\n    }\\n\\n    /// The FTSO feed with proof struct.\\n    struct FeedWithProof {\\n        bytes32[] merkleProof;\\n        Feed body;\\n    }\\n\\n    /// Event emitted when a new feed is published.\\n    event FtsoFeedPublished(\\n        uint32 indexed votingRoundId,\\n        bytes21 indexed id,\\n        int32 value,\\n        uint16 turnoutBIPS,\\n        int8 decimals\\n    );\\n\\n    /**\\n     * Publishes feeds.\\n     * @param _proofs The FTSO feeds with proofs to publish.\\n     */\\n    function publish(FeedWithProof[] calldata _proofs) external;\\n\\n    /**\\n     *The FTSO protocol id.\\n     */\\n    function ftsoProtocolId() external view returns(uint8);\\n\\n    /**\\n     * The size of the feeds history.\\n     */\\n    function feedsHistorySize() external view returns(uint256);\\n\\n    /**\\n     * Returns the current feed.\\n     * @param _feedId Feed id.\\n     */\\n    function getCurrentFeed(bytes21 _feedId) external view returns(Feed memory);\\n\\n    /**\\n     * Returns the feed for given voting round id.\\n     * @param _feedId Feed id.\\n     * @param _votingRoundId Voting round id.\\n     */\\n    function getFeed(bytes21 _feedId, uint256 _votingRoundId) external view returns(Feed memory);\\n}\\n\",\"keccak256\":\"0xa47162b9e14582a8c7d3adf9d6ab2139fd8114479a3eed243d6a8c0e023addf3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoInflationConfigurations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * FtsoInflationConfigurations interface.\\n */\\ninterface IFtsoInflationConfigurations {\\n\\n    /// The FTSO configuration struct.\\n    struct FtsoConfiguration {\\n        // concatenated feed ids - i.e. category + base/quote symbol - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds;\\n        // inflation share for this configuration group\\n        uint24 inflationShare;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs;\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode;\\n    }\\n\\n    /**\\n     * Returns the FTSO configuration at `_index`.\\n     * @param _index The index of the FTSO configuration.\\n     */\\n    function getFtsoConfiguration(uint256 _index) external view returns(FtsoConfiguration memory);\\n\\n    /**\\n     * Returns the FTSO configurations.\\n     */\\n    function getFtsoConfigurations() external view returns(FtsoConfiguration[] memory);\\n}\\n\",\"keccak256\":\"0xdab9920ec53d5fa92f1194f2d8b38a6598ae8cc21fc352ffa96b143ab4227813\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./ftso/interface/IIFtso.sol\\\";\\nimport \\\"./genesis/interface/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IFtsoManager is IFtsoManagerGenesis {\\n\\n    event FtsoAdded(IIFtso ftso, bool add);\\n    event FallbackMode(bool fallbackMode);\\n    event FtsoFallbackMode(IIFtso ftso, bool fallbackMode);\\n    event RewardEpochFinalized(uint256 votepowerBlock, uint256 startBlock);\\n    event PriceEpochFinalized(address chosenFtso, uint256 rewardEpochId);\\n    event InitializingCurrentEpochStateForRevealFailed(IIFtso ftso, uint256 epochId);\\n    event FinalizingPriceEpochFailed(IIFtso ftso, uint256 epochId, IFtso.PriceFinalizationType failingType);\\n    event DistributingRewardsFailed(address ftso, uint256 epochId);\\n    event AccruingUnearnedRewardsFailed(uint256 epochId);\\n    event UseGoodRandomSet(bool useGoodRandom, uint256 maxWaitForGoodRandomSeconds);\\n\\n    function active() external view returns (bool);\\n\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256);\\n\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n    \\n    function getCurrentPriceEpochData() external view \\n        returns (\\n            uint256 _priceEpochId,\\n            uint256 _priceEpochStartTimestamp,\\n            uint256 _priceEpochEndTimestamp,\\n            uint256 _priceEpochRevealEndTimestamp,\\n            uint256 _currentTimestamp\\n        );\\n\\n    function getFtsos() external view returns (IIFtso[] memory _ftsos);\\n\\n    function getPriceEpochConfiguration() external view \\n        returns (\\n            uint256 _firstPriceEpochStartTs,\\n            uint256 _priceEpochDurationSeconds,\\n            uint256 _revealEpochDurationSeconds\\n        );\\n\\n    function getRewardEpochConfiguration() external view \\n        returns (\\n            uint256 _firstRewardEpochStartTs,\\n            uint256 _rewardEpochDurationSeconds\\n        );\\n\\n    function getFallbackMode() external view \\n        returns (\\n            bool _fallbackMode,\\n            IIFtso[] memory _ftsos,\\n            bool[] memory _ftsoInFallbackMode\\n        );\\n}\\n\",\"keccak256\":\"0xa26b0956888497715fc83adbe59a838b80709d4032a03dbb8b5fec894f91b619\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./ftso/interface/IIFtso.sol\\\";\\nimport \\\"./genesis/interface/IFtsoRegistryGenesis.sol\\\";\\n\\ninterface IFtsoRegistry is IFtsoRegistryGenesis {\\n\\n    struct PriceInfo {\\n        uint256 ftsoIndex;\\n        uint256 price;\\n        uint256 decimals;\\n        uint256 timestamp;\\n    }\\n\\n    function getFtso(uint256 _ftsoIndex) external view returns(IIFtso _activeFtsoAddress);\\n    function getFtsoBySymbol(string memory _symbol) external view returns(IIFtso _activeFtsoAddress);\\n    function getSupportedIndices() external view returns(uint256[] memory _supportedIndices);\\n    function getSupportedSymbols() external view returns(string[] memory _supportedSymbols);\\n    function getSupportedFtsos() external view returns(IIFtso[] memory _ftsos);\\n    function getFtsoIndex(string memory _symbol) external view returns (uint256 _assetIndex);\\n    function getFtsoSymbol(uint256 _ftsoIndex) external view returns (string memory _symbol);\\n    function getCurrentPrice(uint256 _ftsoIndex) external view returns(uint256 _price, uint256 _timestamp);\\n    function getCurrentPrice(string memory _symbol) external view returns(uint256 _price, uint256 _timestamp);\\n    function getCurrentPriceWithDecimals(uint256 _assetIndex) external view\\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\\n    function getCurrentPriceWithDecimals(string memory _symbol) external view\\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\\n\\n    function getAllCurrentPrices() external view returns (PriceInfo[] memory);\\n    function getCurrentPricesByIndices(uint256[] memory _indices) external view returns (PriceInfo[] memory);\\n    function getCurrentPricesBySymbols(string[] memory _symbols) external view returns (PriceInfo[] memory);\\n\\n    function getSupportedIndicesAndFtsos() external view \\n        returns(uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);\\n\\n    function getSupportedSymbolsAndFtsos() external view \\n        returns(string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\\n\\n    function getSupportedIndicesAndSymbols() external view \\n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols);\\n\\n    function getSupportedIndicesSymbolsAndFtsos() external view \\n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\\n}\\n\",\"keccak256\":\"0x62f43ca205b3547e6116914138ff189dc714423ebe4df18c549768a41889e6ca\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IFtsoRewardManager {\\n\\n    event RewardClaimed(\\n        address indexed dataProvider,\\n        address indexed whoClaimed,\\n        address indexed sentTo,\\n        uint256 rewardEpoch, \\n        uint256 amount\\n    );\\n\\n    event UnearnedRewardsAccrued(\\n        uint256 epochId,\\n        uint256 reward\\n    );\\n\\n    event RewardsDistributed(\\n        address indexed ftso,\\n        uint256 epochId,\\n        address[] addresses,\\n        uint256[] rewards\\n    );\\n\\n    event RewardClaimsEnabled(\\n        uint256 rewardEpochId\\n    ); \\n\\n    event FeePercentageChanged(\\n        address indexed dataProvider,\\n        uint256 value,\\n        uint256 validFromEpoch\\n    );\\n\\n    event RewardClaimsExpired(\\n        uint256 rewardEpochId\\n    );    \\n\\n    event FtsoRewardManagerActivated(address ftsoRewardManager);\\n    event FtsoRewardManagerDeactivated(address ftsoRewardManager);\\n\\n    /**\\n     * @notice Allows a percentage delegator to claim rewards.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     * @dev Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'.\\n     * @dev Retained for backward compatibility.\\n     * @dev This function is deprecated - use `claim` instead.\\n     */\\n    function claimReward(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs\\n    )\\n        external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Reverts if `msg.sender` is delegating by amount\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256 _rewardEpoch,\\n        bool _wrap\\n    )\\n        external returns (uint256 _rewardAmount);\\n    \\n    /**\\n     * @notice Allows the sender to claim rewards from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     * @dev This function is deprecated - use `claimFromDataProviders` instead.\\n     */\\n    function claimRewardFromDataProviders(\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders\\n    )\\n        external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner from specified data providers.\\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\\n     * @param _wrap                 should reward be wrapped immediately\\n     * @return _rewardAmount        amount of total claimed rewards\\n     * @dev Function can only be used for explicit delegations.\\n     */\\n    function claimFromDataProviders(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint256[] calldata _rewardEpochs,\\n        address[] calldata _dataProviders,\\n        bool _wrap\\n    )\\n        external returns (uint256 _rewardAmount);\\n\\n    /**\\n     * @notice Allows batch claiming for the list of '_rewardOwners' and for all unclaimed epochs <= '_rewardEpoch'.\\n     * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and\\n     *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.\\n     * @notice Claimed amount is automatically wrapped.\\n     * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,\\n     *   then fee is paid to executor for each claimed address from the list.\\n     * @param _rewardOwners         list of reward owners to claim for\\n     * @param _rewardEpoch          last reward epoch to claim for\\n     */\\n    function autoClaim(address[] calldata _rewardOwners, uint256 _rewardEpoch) external;\\n    \\n    /**\\n     * @notice Allows data provider to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS    number representing fee percentage in BIPS\\n     * @return _validFromEpoch      reward epoch number when the setting becomes effective.\\n     */\\n    function setDataProviderFeePercentage(uint256 _feePercentageBIPS)\\n        external returns (uint256 _validFromEpoch);\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the current fee percentage of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     */\\n    function getDataProviderCurrentFeePercentage(address _dataProvider)\\n        external view returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the fee percentage of `_dataProvider` at `_rewardEpoch`\\n     * @param _dataProvider         address representing data provider\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getDataProviderFeePercentage(\\n        address _dataProvider,\\n        uint256 _rewardEpoch\\n    )\\n        external view\\n        returns (uint256 _feePercentageBIPS);\\n\\n    /**\\n     * @notice Returns the scheduled fee percentage changes of `_dataProvider`\\n     * @param _dataProvider         address representing data provider\\n     * @return _feePercentageBIPS   positional array of fee percentages in BIPS\\n     * @return _validFromEpoch      positional array of block numbers the fee settings are effective from\\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\\n     */\\n    function getDataProviderScheduledFeePercentageChanges(address _dataProvider) external view \\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpoch,\\n            bool[] memory _fixed\\n        );\\n\\n    /**\\n     * @notice Returns information on epoch reward\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _totalReward         number representing the total epoch reward\\n     * @return _claimedReward       number representing the amount of total epoch reward that has been claimed\\n     */\\n    function getEpochReward(uint256 _rewardEpoch) external view\\n        returns (uint256 _totalReward, uint256 _claimedReward);\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @return _dataProviders       positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary,\\n        uint256 _rewardEpoch\\n    )\\n        external view \\n        returns (\\n            address[] memory _dataProviders,\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`\\n     * @param _beneficiary          address of reward beneficiary\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProviders        positional array of addresses representing data providers\\n     * @return _rewardAmounts       positional array of reward amounts\\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\\n     * @return _claimable           boolean value indicating if rewards are claimable\\n     */\\n    function getStateOfRewardsFromDataProviders(\\n        address _beneficiary,\\n        uint256 _rewardEpoch,\\n        address[] calldata _dataProviders\\n    )\\n        external view\\n        returns (\\n            uint256[] memory _rewardAmounts,\\n            bool[] memory _claimed,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * @notice Returns the start and the end of the reward epoch range for which the reward is claimable\\n     * @param _startEpochId         the oldest epoch id that allows reward claiming\\n     * @param _endEpochId           the newest epoch id that allows reward claiming\\n     */\\n    function getEpochsWithClaimableRewards() external view \\n        returns (\\n            uint256 _startEpochId,\\n            uint256 _endEpochId\\n        );\\n\\n    /**\\n     * @notice Returns the next claimable reward epoch for '_rewardOwner'.\\n     * @param _rewardOwner          address of the reward owner\\n     */\\n    function nextClaimableRewardEpoch(address _rewardOwner) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the array of claimable epoch ids for which the reward has not yet been claimed\\n     * @param _beneficiary          address of reward beneficiary\\n     * @return _epochIds            array of epoch ids\\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\\n     */\\n    function getEpochsWithUnclaimedRewards(address _beneficiary) external view returns (\\n        uint256[] memory _epochIds\\n    );\\n\\n    /**\\n     * @notice Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`\\n     * @param _rewardEpoch          reward epoch number\\n     * @param _dataProvider         address representing the data provider\\n     * @param _claimer              address representing the claimer\\n     * @return _claimed             boolean indicating if reward has been claimed\\n     * @return _amount              number representing the claimed amount\\n     */\\n    function getClaimedReward(\\n        uint256 _rewardEpoch,\\n        address _dataProvider,\\n        address _claimer\\n    )\\n        external view\\n        returns (\\n            bool _claimed,\\n            uint256 _amount\\n        );\\n\\n    /**\\n     * @notice Return reward epoch that will expire, when new reward epoch will start\\n     * @return Reward epoch id that will expire next\\n     */\\n    function getRewardEpochToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * @notice Return reward epoch vote power block\\n     * @param _rewardEpoch          reward epoch number\\n     */\\n    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256);\\n\\n    /**\\n     * @notice Return current reward epoch number\\n     */\\n    function getCurrentRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Return initial reward epoch number\\n     */\\n    function getInitialRewardEpoch() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`\\n     * @param _rewardEpoch                      reward epoch number\\n     * @param _dataProvider                     address representing the data provider\\n     * @return _rewardAmount                    number representing the amount of rewards\\n     * @return _votePowerIgnoringRevocation     number representing the vote power ignoring revocations\\n     */\\n    function getDataProviderPerformanceInfo(\\n        uint256 _rewardEpoch,\\n        address _dataProvider\\n    )\\n        external view \\n        returns (\\n            uint256 _rewardAmount,\\n            uint256 _votePowerIgnoringRevocation\\n        );\\n}\\n\",\"keccak256\":\"0x03ea94df67caf6f0a31f2d24a08e4ecb3703d177ae181ecf3fd2ddd4d59ac102\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardOffersManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoRewardOffersManager interface.\\n */\\ninterface IFtsoRewardOffersManager {\\n\\n    /**\\n    * Defines a reward offer.\\n    */\\n    struct Offer {\\n        // amount (in wei) of reward in native coin\\n        uint120 amount;\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId;\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS;\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM;\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM;\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress;\\n    }\\n\\n    /// Event emitted when the minimal rewards offer value is set.\\n    event MinimalRewardsOfferValueSet(uint256 valueWei);\\n\\n    /// Event emitted when a reward offer is received.\\n    event RewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed id - i.e. category + base/quote symbol\\n        bytes21 feedId,\\n        // number of decimals (negative exponent)\\n        int8 decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median\\n        uint24 secondaryBandWidthPPM,\\n        // address that can claim undistributed part of the reward (or burn address)\\n        address claimBackAddress\\n    );\\n\\n    /// Event emitted when inflation rewards are offered.\\n    event InflationRewardsOffered(\\n        // reward epoch id\\n        uint24 indexed rewardEpochId,\\n        // feed ids - i.e. category + base/quote symbols - multiple of 21 (one feedId is bytes21)\\n        bytes feedIds,\\n        // decimals encoded to - multiple of 1 (int8)\\n        bytes decimals,\\n        // amount (in wei) of reward in native coin\\n        uint256 amount,\\n        // minimal reward eligibility turnout threshold in BIPS (basis points)\\n        uint16 minRewardedTurnoutBIPS,\\n        // primary band reward share in PPM (parts per million)\\n        uint24 primaryBandRewardSharePPM,\\n        // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)\\n        bytes secondaryBandWidthPPMs,\\n        // rewards split mode (0 means equally, 1 means random,...)\\n        uint16 mode\\n    );\\n\\n    /**\\n     * Allows community to offer rewards.\\n     * @param _nextRewardEpochId The next reward epoch id.\\n     * @param _offers The list of offers.\\n     */\\n    function offerRewards(\\n        uint24 _nextRewardEpochId,\\n        Offer[] calldata _offers\\n    )\\n        external payable;\\n\\n    /**\\n     * Minimal rewards offer value (in wei).\\n     */\\n    function minimalRewardsOfferValueWei() external view returns(uint256);\\n}\\n\",\"keccak256\":\"0x488c8c4d073354261968c3c8ebb69e37318a36a18209ef1afdfe58a12a98cda2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGenericRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IGenericRewardManager {\\n\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed sentTo,\\n        uint256 amount\\n    );\\n\\n    event RewardsDistributed(\\n        address[] addresses,\\n        uint256[] rewards\\n    );\\n\\n    event ClaimExecutorsChanged(\\n        address rewardOwner,\\n        address[] executors\\n    );\\n\\n    event AllowedClaimRecipientsChanged(\\n        address rewardOwner,\\n        address[] recipients\\n    );\\n\\n    event RewardManagerActivated(address rewardManager);\\n    event RewardManagerDeactivated(address rewardManager);\\n\\n\\n    /**\\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf.\\n     *   this approval is done by calling `setClaimExecutors`.\\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\\n     *   call, we allow the owner to control the timing of the calls.\\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner or\\n     *   one of the addresses set by `setAllowedClaimRecipients`.\\n     * @param _rewardOwner          address of the reward owner\\n     * @param _recipient            address to transfer funds to\\n     * @param _rewardAmount         amount of rewards to claim\\n     * @param _wrap                 should reward be wrapped immediately\\n     */\\n    function claim(address _rewardOwner, address payable _recipient, uint256 _rewardAmount, bool _wrap) external;\\n\\n    /**\\n     * Set the addresses of executors, who are allowed to call `claim`.\\n     * @param _executors The new executors. All old executors will be deleted and replaced by these.\\n     */    \\n    function setClaimExecutors(address[] memory _executors) external;\\n\\n    /**\\n     * Set the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.\\n     */    \\n    function setAllowedClaimRecipients(address[] memory _recipients) external;\\n\\n    /**\\n     * @notice Allows reward claiming\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * @notice Returns information of beneficiary rewards\\n     * @param _beneficiary          beneficiary address\\n     * @return _totalReward         number representing the total reward\\n     * @return _claimedReward       number representing the amount of total reward that has been claimed\\n     */\\n    function getStateOfRewards(\\n        address _beneficiary\\n    )\\n        external view \\n        returns (\\n            uint256 _totalReward,\\n            uint256 _claimedReward\\n        );\\n\\n    /**\\n     * Get the addresses of executors, who are allowed to call `claim`.\\n     */    \\n    function claimExecutors(address _rewardOwner) external view returns (address[] memory);\\n    \\n    /**\\n     * Get the addresses of allowed recipients in the methods `claim`.\\n     * Apart from these, the reward owner is always an allowed recipient.\\n     */    \\n    function allowedClaimRecipients(address _rewardOwner) external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x856335231d0072e1c66b9fc5218bbb8fd3dd177b7cdd1aa412e3574c5d456912\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceSettings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * A special contract that holds Flare governance address.\\n * This contract enables updating governance address and timelock only by hard forking the network,\\n * meaning only by updating validator code.\\n */\\ninterface IGovernanceSettings {\\n    /**\\n     * Get the governance account address.\\n     * The governance address can only be changed by a hardfork.\\n     */\\n    function getGovernanceAddress() external view returns (address);\\n    \\n    /**\\n     * Get the time in seconds that must pass between a governance call and execution.\\n     * The timelock value can only be changed by a hardfork.\\n     */\\n    function getTimelock() external view returns (uint256);\\n    \\n    /**\\n     * Get the addresses of the accounts that are allowed to execute the timelocked governance calls\\n     * once the timelock period expires.\\n     * Executors can be changed without a hardfork, via a normal governance call.\\n     */\\n    function getExecutors() external view returns (address[] memory);\\n    \\n    /**\\n     * Check whether an address is one of the executors.\\n     */\\n    function isExecutor(address _address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe8bbb796ce096af1077bbe3dad9bccb2e7ded0ce027abdde3dda3766f6981880\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for contracts delegating their governance vote power.\\n */\\ninterface IGovernanceVotePower {\\n    /**\\n     * Delegates all governance vote power of `msg.sender` to address `_to`.\\n     * @param _to The address of the recipient.\\n     */\\n    function delegate(address _to) external;\\n\\n    /**\\n     * Undelegates all governance vote power of `msg.sender`.\\n     */\\n    function undelegate() external;\\n\\n    /**\\n     * Gets the governance vote power of an address at a given block number, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the vote power.\\n     * @return Governance vote power of `_who` at `_blockNumber`.\\n     */\\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * Gets the governance vote power of an address at the latest block, including\\n     * all delegations made to it.\\n     * @param _who The address being queried.\\n     * @return Governance vote power of `account` at the lastest block.\\n     */\\n    function getVotes(address _who) external view returns (uint256);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at a given block number.\\n     * @param _who The address being queried.\\n     * @param _blockNumber The block number at which to fetch the address.\\n     * @return Address where `_who` was delegating its governance vote power at block `_blockNumber`.\\n     */\\n    function getDelegateOfAt(address _who, uint256 _blockNumber) external view returns (address);\\n\\n    /**\\n     * Gets the address an account is delegating its governance vote power to, at the latest block number.\\n     * @param _who The address being queried.\\n     * @return Address where `_who` is currently delegating its governance vote power.\\n     */\\n    function getDelegateOfAtNow(address _who) external view returns (address);\\n}\\n\",\"keccak256\":\"0xac45cb04eedb4f19533df4867eb6cd50874a55ef04d73f4d2dc3d3b7d3927e3c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IIncreaseManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Increase manager interface.\\n */\\ninterface IIncreaseManager {\\n    function getIncentiveDuration() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd483962efcae8fcada9b8c8112c497939ac4289c441280e5a3f468056b2c4e0f\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApi.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IJsonApi\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches data from the given url and then edits the information with a\\n * jq transformation.\\n * @custom:verification  Data is fetched from an url `url`. The received data is then processed with jq as\\n * the `postprocessJq` states. The structure of the final json is written in the `abi_signature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IJsonApi {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param url URL of the data source\\n     * @param postprocessJq jq filter to postprocess the data\\n     * @param abi_signature ABI signature of the data\\n     */\\n    struct RequestBody {\\n        string url;\\n        string postprocessJq;\\n        string abi_signature;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param abi_encoded_data ABI encoded data\\n     */\\n    struct ResponseBody {\\n        bytes abi_encoded_data;\\n    }\\n}\\n\",\"keccak256\":\"0xd9d1b4883b23509d9a59860cc47e90f2b44627119c6b2717a339e8a83e2fbcee\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IJsonApiVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IJsonApi.sol\\\";\\n\\ninterface IJsonApiVerification {\\n  function verifyJsonApi(IJsonApi.Proof calldata _proof) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x96f153adaed0eb9edc5ecf19681ce35f17b3f35e6d86a6f6666fb33ad0c9e759\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirror.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\nimport \\\"./IPChainVotePower.sol\\\";\\nimport \\\"./IPChainStakeMirrorVerifier.sol\\\";\\n\\n\\n/**\\n * Interface for the `PChainStakeMirror` contract.\\n */\\ninterface IPChainStakeMirror is IPChainVotePower {\\n\\n    /**\\n     * Event emitted when max updates per block is set.\\n     * @param maxUpdatesPerBlock new number of max updated per block\\n     */\\n    event MaxUpdatesPerBlockSet(uint256 maxUpdatesPerBlock);\\n\\n    /**\\n     * Event emitted when the stake is confirmed.\\n     * @param owner The address who opened the stake.\\n     * @param nodeId Node id to which the stake was added.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     * @param pChainTxId P-chain transaction id.\\n     */\\n    event StakeConfirmed(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei,\\n        bytes32 pChainTxId\\n    );\\n\\n    /**\\n     * Event emitted when the stake has ended.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeEnded(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Event emitted when the stake was revoked.\\n     * @param owner The address whose stake has ended.\\n     * @param nodeId Node id from which the stake was removed.\\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\\n     * @param amountWei Stake amount (in wei).\\n     */\\n    event StakeRevoked(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        bytes32 indexed txHash,\\n        uint256 amountWei\\n    );\\n\\n    /**\\n     * Method for P-chain stake mirroring using `PChainStake` data and Merkle proof.\\n     * @param _stakeData Information about P-chain stake.\\n     * @param _merkleProof Merkle proof that should be used to prove the P-chain stake.\\n     */\\n    function mirrorStake(\\n        IPChainStakeMirrorVerifier.PChainStake calldata _stakeData,\\n        bytes32[] calldata _merkleProof\\n    )\\n        external;\\n\\n    /**\\n     * Method for checking if active stake (stake start time <= block.timestamp < stake end time) was already mirrored.\\n     * @param _txId P-chain stake transaction id.\\n     * @param _inputAddress P-chain address that opened stake.\\n     * @return True if stake is active and mirrored.\\n     */\\n    function isActiveStakeMirrored(bytes32 _txId, bytes20 _inputAddress) external view returns(bool);\\n\\n    /**\\n     * Total amount of tokens at current block.\\n     * @return The current total amount of tokens.\\n     **/\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried.\\n     * @return The total amount of tokens at `_blockNumber`.\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at current block.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @return The current balance.\\n     **/\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /**\\n     * Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x8c70a1ae9079bb9d29c8e2dde781f546b6cb621f0b7cc943b9cbcbd52718bb41\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirrorMultiSigVoting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\n/**\\n * Interface for the `PChainStakeMirrorMultiSigVoting` contract.\\n */\\ninterface IPChainStakeMirrorMultiSigVoting {\\n\\n    /**\\n     * Structure describing votes.\\n     */\\n    struct PChainVotes {\\n        bytes32 merkleRoot;\\n        address[] votes;\\n    }\\n\\n    /**\\n     * Event emitted when voting for specific epoch is reset.\\n     * @param epochId Epoch id.\\n     */\\n    event PChainStakeMirrorVotingReset(uint256 epochId);\\n\\n    /**\\n     * Event emitted when voting threshold is updated.\\n     * @param votingThreshold New voting threshold.\\n     */\\n    event PChainStakeMirrorVotingThresholdSet(uint256 votingThreshold);\\n\\n    /**\\n     * Event emitted when voters are set.\\n     * @param voters List of new voters.\\n     */\\n    event PChainStakeMirrorVotersSet(address[] voters);\\n\\n    /**\\n     * Event emitted when voting for specific epoch is finalized.\\n     * @param epochId Epoch id.\\n     * @param merkleRoot Voted Merkle root for that epoch id.\\n     */\\n    event PChainStakeMirrorVotingFinalized(uint256 indexed epochId, bytes32 merkleRoot);\\n\\n    /**\\n     * Event emitted when vote for specific epoch is submitted.\\n     * @param epochId Epoch id.\\n     * @param voter Voter address.\\n     * @param merkleRoot Merkle root voter voted for in given epoch.\\n     */\\n    event PChainStakeMirrorVoteSubmitted(uint256 epochId, address voter, bytes32 merkleRoot);\\n\\n    /**\\n     * Event emitted when validator uptime vote for specific reward epoch is submitted.\\n     * @param rewardEpochId Reward epoch id.\\n     * @param timestamp Timestamp of the block when the vote happened, in seconds from UNIX epoch.\\n     * @param voter Voter address.\\n     * @param nodeIds List of node ids with high enough uptime.\\n     */\\n    event PChainStakeMirrorValidatorUptimeVoteSubmitted(\\n        uint256 indexed rewardEpochId,\\n        uint256 indexed timestamp,\\n        address voter,\\n        bytes20[] nodeIds\\n    );\\n\\n    /**\\n     * Method for submitting Merkle roots for given epoch.\\n     * @param _epochId Epoch id voter is submitting vote for.\\n     * @param _merkleRoot Merkle root for given epoch.\\n     * **NOTE**: It reverts in case voter is not eligible to vote, epoch has not ended yet or is already finalized\\n     *          or voter is submitting vote for the second time for the same Merkle root\\n                (voter can submit a vote for a different Merkle root even if voted already).\\n     */\\n    function submitVote(uint256 _epochId, bytes32 _merkleRoot) external;\\n\\n    /**\\n     * Method for submitting node ids of those validators that have high enough uptime in given reward epoch.\\n     * @param _rewardEpochId Reward epoch id voter is submitting vote for.\\n     * @param _nodeIds List of validators (node ids) with high enough uptime in given reward epoch.\\n     * **NOTE**: Reward epochs are aligned with FTSO reward epochs.\\n     */\\n    function submitValidatorUptimeVote(uint256 _rewardEpochId, bytes20[] calldata _nodeIds) external;\\n\\n    /**\\n     * Returns epochs configuration data.\\n     * @return _firstEpochStartTs First epoch start timestamp\\n     * @return _epochDurationSeconds Epoch duration in seconds\\n     */\\n    function getEpochConfiguration() external view\\n        returns (\\n            uint256 _firstEpochStartTs,\\n            uint256 _epochDurationSeconds\\n        );\\n\\n    /**\\n     * Returns id of the epoch at the specified timestamp.\\n     * @param _timestamp Timestamp as seconds from unix epoch\\n     */\\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\\n\\n    /**\\n     * Returns Merkle root for the given `_epochId`.\\n     * @param _epochId Epoch id of the interest.\\n     * @return Merkle root for finalized epoch id and `bytes32(0)` otherwise.\\n     */\\n    function getMerkleRoot(uint256 _epochId) external view returns(bytes32);\\n\\n     /**\\n     * Returns all votes for the given `_epochId` util epoch is finalized. Reverts later.\\n     * @param _epochId Epoch id of the interest.\\n     * @return Votes for for the given `_epochId`.\\n     */\\n    function getVotes(uint256 _epochId) external view returns(PChainVotes[] memory);\\n\\n    /**\\n     * Checks if `_voter` should vote for the given `_epochId`.\\n     * @param _epochId Epoch id of the interest.\\n     * @param _voter Address of the voter.\\n     * @return False if voter is not eligible to vote, epoch already finalized or voter already voted. True otherwise.\\n     * **NOTE**: The method will return true even if epoch has not ended yet - `submitVote` will revert in that case.\\n     */\\n    function shouldVote(uint256 _epochId, address _voter) external view returns(bool);\\n\\n    /**\\n     * Returns the list of all voters.\\n     * @return List of all voters.\\n     */\\n    function getVoters() external view returns(address[] memory);\\n\\n     /**\\n     * Returns the voting threshold.\\n     * @return Voting threshold.\\n     */\\n    function getVotingThreshold() external view returns(uint256);\\n\\n    /**\\n     * Returns current epoch id.\\n     * @return Current epoch id.\\n     */\\n    function getCurrentEpochId() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x6cd90b58cf75763f2e5188b2cf3f8655ba1f55259fe68ec3f938afdbfff0b78c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirrorVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\npragma abicoder v2;\\n\\n/**\\n * Interface with structure for P-chain stake mirror verifications.\\n */\\ninterface IPChainStakeMirrorVerifier {\\n\\n    /**\\n     * Structure describing the P-chain stake.\\n     */\\n    struct PChainStake {\\n        // Hash of the transaction on the underlying chain.\\n        bytes32 txId;\\n        // Type of the staking/delegation transaction: '0' for 'ADD_VALIDATOR_TX' and '1' for 'ADD_DELEGATOR_TX'.\\n        uint8 stakingType;\\n        // Input address that triggered the staking or delegation transaction.\\n        // See https://support.avax.network/en/articles/4596397-what-is-an-address for address definition for P-chain.\\n        bytes20 inputAddress;\\n        // NodeID to which staking or delegation is done.\\n        // For definitions, see https://github.com/ava-labs/avalanchego/blob/master/ids/node_id.go.\\n        bytes20 nodeId;\\n        // Start time of the staking/delegation in seconds (Unix epoch).\\n        uint64 startTime;\\n        // End time of the staking/delegation in seconds (Unix epoch).\\n        uint64 endTime;\\n        // Staked or delegated amount in Gwei (nano FLR).\\n        uint64 weight;\\n    }\\n}\\n\",\"keccak256\":\"0x1a1d0a1302b59249f9d2ca2700bb9759bc66bae73fe1c920cf4c20ac75b475fe\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPChainVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Interface for the vote power part of the `PChainStakeMirror` contract.\\n */\\ninterface IPChainVotePower {\\n\\n    /**\\n     * Event triggered when a stake is confirmed or at the time it ends.\\n     * Definition: `votePowerFromTo(owner, nodeId)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * @param owner The account that has changed the amount of vote power it is staking.\\n     * @param nodeId The node id whose received vote power has changed.\\n     * @param priorVotePower The vote power originally on that node id.\\n     * @param newVotePower The new vote power that triggered this event.\\n     */\\n    event VotePowerChanged(\\n        address indexed owner,\\n        bytes20 indexed nodeId,\\n        uint256 priorVotePower,\\n        uint256 newVotePower\\n    );\\n\\n    /**\\n     * Emitted when a vote power cache entry is created.\\n     * Allows history cleaners to track vote power cache cleanup opportunities off-chain.\\n     * @param nodeId The node id whose vote power has just been cached.\\n     * @param blockNumber The block number at which the vote power has been cached.\\n     */\\n    event VotePowerCacheCreated(bytes20 nodeId, uint256 blockNumber);\\n\\n    /**\\n    * Get the vote power of `_owner` at block `_blockNumber` using cache.\\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n    *   Can only be used if _blockNumber is in the past, otherwise reverts.\\n    * @param _owner The node id to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_owner` at `_blockNumber`.\\n    */\\n    function votePowerOfAtCached(bytes20 _owner, uint256 _blockNumber) external returns(uint256);\\n\\n    /**\\n    * Get the total vote power at block `_blockNumber` using cache.\\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n    *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The total vote power at the block (sum of all accounts' vote powers).\\n    */\\n    function totalVotePowerAtCached(uint256 _blockNumber) external returns(uint256);\\n\\n    /**\\n     * Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns(uint256);\\n\\n    /**\\n    * Get the total vote power at block `_blockNumber`\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The total vote power at the block  (sum of all accounts' vote powers).\\n    */\\n    function totalVotePowerAt(uint _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner.\\n     * @param _owner The address being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOf(address _owner)\\n        external view\\n        returns (\\n            bytes20[] memory _nodeIds,\\n            uint256[] memory _amounts\\n        );\\n\\n    /**\\n     * Get the amounts and node ids being staked to by a vote power owner,\\n     * at a given block.\\n     * @param _owner The address being queried.\\n     * @param _blockNumber The block number being queried.\\n     * @return _nodeIds Array of node ids.\\n     * @return _amounts Array of staked amounts, for each node id.\\n     */\\n    function stakesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external view\\n        returns (\\n            bytes20[] memory _nodeIds,\\n            uint256[] memory _amounts\\n        );\\n\\n    /**\\n     * Get the current vote power of `_nodeId`.\\n     * @param _nodeId The node id to get voting power.\\n     * @return Current vote power of `_nodeId`.\\n     */\\n    function votePowerOf(bytes20 _nodeId) external view returns(uint256);\\n\\n    /**\\n    * Get the vote power of `_nodeId` at block `_blockNumber`\\n    * @param _nodeId The node id to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_nodeId` at `_blockNumber`.\\n    */\\n    function votePowerOfAt(bytes20 _nodeId, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n    * Get current staked vote power from `_owner` staked to `_nodeId`.\\n    * @param _owner Address of vote power owner.\\n    * @param _nodeId Node id.\\n    * @return The staked vote power.\\n    */\\n    function votePowerFromTo(address _owner, bytes20 _nodeId) external view returns(uint256);\\n\\n    /**\\n    * Get current staked vote power from `_owner` staked to `_nodeId` at `_blockNumber`.\\n    * @param _owner Address of vote power owner.\\n    * @param _nodeId Node id.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The staked vote power.\\n    */\\n    function votePowerFromToAt(address _owner, bytes20 _nodeId, uint _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * Return vote powers for several node ids in a batch.\\n     * @param _nodeIds The list of node ids to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */\\n    function batchVotePowerOfAt(\\n        bytes20[] memory _nodeIds,\\n        uint256 _blockNumber\\n    ) external view returns(uint256[] memory);\\n}\\n\",\"keccak256\":\"0x23e31ef2ab9227795930728dc240fbe59f31f1b05e595ee137acc1e5e6e8497e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPayment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IPayment\\n * @custom:id 0x01\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.\\n * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment\\n * transaction should be formed to be provable by this attestation type.\\n * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an\\n * optional payment reference.\\n * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or\\n * relevant indexer.\\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient\\n * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\\n *\\n * Once the transaction is received, the payment summary is computed according to the rules for the source chain.\\n * If the summary is successfully calculated, the response is assembled from the summary.\\n * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.\\n * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.\\n * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.\\n *\\n * If the summary is not successfully calculated, the attestation request is rejected.\\n * @custom:lut `blockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IPayment {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Payment attestation type\\n     * @param transactionId ID of the payment transaction.\\n     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.\\n     * Always 0 for the non-utxo chains.\\n     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.\\n     * Always 0 for the non-utxo chains.\\n     */\\n    struct RequestBody {\\n        bytes32 transactionId;\\n        uint256 inUtxo;\\n        uint256 utxo;\\n    }\\n\\n    /**\\n     * @notice Response body for Payment attestation type\\n     * @param blockNumber Number of the block in which the transaction is included.\\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\\n     * @param sourceAddressHash Standard address hash of the source address.\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @param receivingAddressHash Standard address hash of the receiving address.\\n     * The zero 32-byte string if there is no receivingAddress (if `status` is not success).\\n     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param spentAmount Amount in minimal units spent by the source address.\\n     * @param intendedSpentAmount Amount in minimal units to be spent by the source address.\\n     * Relevant if the transaction status is unsuccessful.\\n     * @param receivedAmount Amount in minimal units received by the receiving address.\\n     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.\\n     * Relevant if the transaction is unsuccessful.\\n     * @param standardPaymentReference Standard payment reference of the transaction.\\n     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.\\n     * @param status Succes status of the transaction: 0 - success, 1 - failed by sender's fault,\\n     * 2 - failed by receiver's fault.\\n     */\\n    struct ResponseBody {\\n        uint64 blockNumber;\\n        uint64 blockTimestamp;\\n        bytes32 sourceAddressHash;\\n        bytes32 sourceAddressesRoot;\\n        bytes32 receivingAddressHash;\\n        bytes32 intendedReceivingAddressHash;\\n        int256 spentAmount;\\n        int256 intendedSpentAmount;\\n        int256 receivedAmount;\\n        int256 intendedReceivedAmount;\\n        bytes32 standardPaymentReference;\\n        bool oneToOne;\\n        uint8 status;\\n    }\\n}\\n\",\"keccak256\":\"0x9f24ac36dce88e3c80307b47d7de628941e9877ddc2a935676532fadcb470104\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPaymentVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IPayment.sol\\\";\\n\\ninterface IPaymentVerification {\\n\\n    function verifyPayment(IPayment.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x8bceac23579dfbc63757031cf4dfd4fab2b4265cc4684395e357df50b4ee7e55\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IPriceSubmitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./genesis/interface/IFtsoGenesis.sol\\\";\\nimport \\\"./genesis/interface/IFtsoRegistryGenesis.sol\\\";\\nimport \\\"./genesis/interface/IFtsoManagerGenesis.sol\\\";\\n\\ninterface IPriceSubmitter {\\n    /**\\n     * Event emitted when hash was submitted through PriceSubmitter.\\n     * @param submitter the address of the sender\\n     * @param epochId current price epoch id\\n     * @param hash the submitted hash\\n     * @param timestamp current block timestamp\\n     */\\n    event HashSubmitted(\\n        address indexed submitter,\\n        uint256 indexed epochId,\\n        bytes32 hash,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * Event emitted when prices were revealed through PriceSubmitter.\\n     * @param voter the address of the sender\\n     * @param epochId id of the epoch in which the price hash was submitted\\n     * @param ftsos array of ftsos that correspond to the indexes in the call\\n     * @param prices the submitted prices\\n     * @param timestamp current block timestamp\\n     */\\n    event PricesRevealed(\\n        address indexed voter,\\n        uint256 indexed epochId,\\n        IFtsoGenesis[] ftsos,\\n        uint256[] prices,\\n        uint256 random,\\n        uint256 timestamp\\n    );\\n    \\n    /**\\n     * @notice Submits hash for current epoch\\n     * @param _epochId              Target epoch id to which hash is submitted\\n     * @param _hash                 Hash of ftso indices, prices, random number and voter address\\n     * @notice Emits HashSubmitted event\\n     */\\n    function submitHash(\\n        uint256 _epochId,\\n        bytes32 _hash\\n    ) external;\\n\\n    /**\\n     * @notice Reveals submitted prices during epoch reveal period\\n     * @param _epochId              Id of the epoch in which the price hashes was submitted\\n     * @param _ftsoIndices          List of increasing ftso indices\\n     * @param _prices               List of submitted prices in USD\\n     * @param _random               Submitted random number\\n     * @notice The hash of ftso indices, prices, random number and voter address must be equal to the submitted hash\\n     * @notice Emits PricesRevealed event\\n     */\\n    function revealPrices(\\n        uint256 _epochId,\\n        uint256[] memory _ftsoIndices,\\n        uint256[] memory _prices,\\n        uint256 _random\\n    ) external;\\n\\n    /**\\n     * Returns bitmap of all ftso's for which `_voter` is allowed to submit prices/hashes.\\n     * If voter is allowed to vote for ftso at index (see *_FTSO_INDEX), the corrsponding\\n     * bit in the result will be 1.\\n     */    \\n    function voterWhitelistBitmap(address _voter) external view returns (uint256);\\n\\n    function getVoterWhitelister() external view returns (address);\\n    function getFtsoRegistry() external view returns (IFtsoRegistryGenesis);\\n    function getFtsoManager() external view returns (IFtsoManagerGenesis);\\n\\n    /**\\n     * @notice Returns current random number\\n     */\\n    function getCurrentRandom() external view returns (uint256);\\n    \\n    /**\\n     * @notice Returns random number of the specified epoch\\n     * @param _epochId              Id of the epoch\\n     */\\n    function getRandom(uint256 _epochId) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbc11b84add6edc5e6bd3a5258e142121a109012fd3d2272890f8a257960e0ddc\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRNat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRNatAccount.sol\\\";\\nimport \\\"./IWNat.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IRNat is IERC20Metadata {\\n\\n    event RNatAccountCreated(address owner, IRNatAccount rNatAccount);\\n    event ProjectAdded(uint256 indexed id, string name, address distributor, bool currentMonthDistributionEnabled);\\n    event ProjectUpdated(uint256 indexed id, string name, address distributor, bool currentMonthDistributionEnabled);\\n    event RewardsAssigned(uint256 indexed projectId, uint256 indexed month, uint128 amount);\\n    event RewardsUnassigned(uint256 indexed projectId, uint256 indexed month, uint128 amount);\\n    event RewardsDistributed(\\n        uint256 indexed projectId,\\n        uint256 indexed month,\\n        address[] recipients,\\n        uint128[] amounts\\n    );\\n    event RewardsClaimed(uint256 indexed projectId, uint256 indexed month, address indexed owner, uint128 amount);\\n    event UnclaimedRewardsUnassigned(uint256 indexed projectId, uint256 indexed month, uint128 amount);\\n    event UnassignedRewardsWithdrawn(address recipient, uint128 amount);\\n    event DistributionPermissionUpdated(uint256[] projectIds, bool disabled);\\n    event ClaimingPermissionUpdated(uint256[] projectIds, bool disabled);\\n\\n    /**\\n     * Distributes the rewards of a project for a given month to a list of recipients.\\n     * It must be called by the project's distributor.\\n     * It can only be called for the last or current month (if enabled).\\n     * @param _projectId The id of the project.\\n     * @param _month The month of the rewards.\\n     * @param _recipients The addresses of the recipients.\\n     * @param _amountsWei The amounts of rewards to distribute to each recipient (in wei).\\n     */\\n    function distributeRewards(\\n        uint256 _projectId,\\n        uint256 _month,\\n        address[] calldata _recipients,\\n        uint128[] calldata _amountsWei\\n    )\\n        external;\\n\\n    /**\\n     * Claim rewards for a list of projects up to the given month.\\n     * @param _projectIds The ids of the projects.\\n     * @param _month The month up to which (including) rewards will be claimed.\\n     * @return _claimedRewardsWei The total amount of rewards claimed (in wei).\\n     */\\n    function claimRewards(\\n        uint256[] calldata _projectIds,\\n        uint256 _month\\n    )\\n        external\\n        returns (\\n            uint128 _claimedRewardsWei\\n        );\\n\\n    /**\\n     * Sets the addresses of executors and adds the owner as an executor.\\n     *\\n     * If any of the executors is a registered executor, some fee needs to be paid.\\n     * @param _executors The new executors. All old executors will be deleted and replaced by these.\\n     */\\n    function setClaimExecutors(address[] calldata _executors) external payable;\\n\\n    /**\\n     * Allows the caller to withdraw `WNat` wrapped tokens from their RNat account to the owner account.\\n     * In case there are some self-destruct native tokens left on the contract,\\n     * they can be transferred to the owner account using this method and `_wrap = false`.\\n     * @param _amount Amount of tokens to transfer (in wei).\\n     * @param _wrap If `true`, the tokens will be sent wrapped in `WNat`. If `false`, they will be sent as `Nat`.\\n     */\\n    function withdraw(uint128 _amount, bool _wrap) external;\\n\\n    /**\\n     * Allows the caller to withdraw `WNat` wrapped tokens from their RNat account to the owner account.\\n     * If some tokens are still locked, only 50% of them will be withdrawn, the rest will be burned as a penalty.\\n     * In case there are some self-destruct native tokens left on the contract,\\n     * they can be transferred to the owner account using this method and `_wrap = false`.\\n     * @param _wrap If `true`, the tokens will be sent wrapped in `WNat`. If `false`, they will be sent as `Nat`.\\n     */\\n    function withdrawAll(bool _wrap) external;\\n\\n    /**\\n     * Allows the caller to transfer ERC-20 tokens from their RNat account to the owner account.\\n     *\\n     * The main use case is to move ERC-20 tokes received by mistake (by an airdrop, for example) out of the\\n     * RNat account and move them into the main account, where they can be more easily managed.\\n     *\\n     * Reverts if the target token is the `WNat` contract: use method `withdraw` or `withdrawAll` for that.\\n     * @param _token Target token contract address.\\n     * @param _amount Amount of tokens to transfer.\\n     */\\n    function transferExternalToken(IERC20 _token, uint256 _amount) external;\\n\\n    /**\\n     * Gets owner's RNat account. If it doesn't exist it reverts.\\n     * @param _owner Account to query.\\n     * @return Address of its RNat account.\\n     */\\n    function getRNatAccount(address _owner) external view returns (IRNatAccount);\\n\\n    /**\\n     * Returns the timestamp of the start of the first month.\\n     */\\n    function firstMonthStartTs() external view returns (uint256);\\n\\n    /**\\n     * Returns the `WNat` contract.\\n     */\\n    function wNat() external view returns(IWNat);\\n\\n    /**\\n     * Gets the current month.\\n     * @return The current month.\\n     */\\n    function getCurrentMonth() external view returns (uint256);\\n\\n    /**\\n     * Gets the total number of projects.\\n     * @return The total number of projects.\\n     */\\n    function getProjectsCount() external view returns (uint256);\\n\\n    /**\\n     * Gets the basic information of all projects.\\n     * @return _names The names of the projects.\\n     * @return _claimingDisabled Whether claiming is disabled for each project.\\n     */\\n    function getProjectsBasicInfo() external view returns (string[] memory _names, bool[] memory _claimingDisabled);\\n\\n    /**\\n     * Gets the information of a project.\\n     * @param _projectId The id of the project.\\n     * @return _name The name of the project.\\n     * @return _distributor The address of the distributor.\\n     * @return _currentMonthDistributionEnabled Whether distribution is enabled for the current month.\\n     * @return _distributionDisabled Whether distribution is disabled.\\n     * @return _claimingDisabled Whether claiming is disabled.\\n     * @return _totalAssignedRewards The total amount of rewards assigned to the project (in wei).\\n     * @return _totalDistributedRewards The total amount of rewards distributed by the project (in wei).\\n     * @return _totalClaimedRewards The total amount of rewards claimed from the project (in wei).\\n     * @return _totalUnassignedUnclaimedRewards The total amount of unassigned unclaimed rewards (in wei).\\n     * @return _monthsWithRewards The months with rewards.\\n     */\\n    function getProjectInfo(uint256 _projectId)\\n        external view\\n        returns (\\n            string memory _name,\\n            address _distributor,\\n            bool _currentMonthDistributionEnabled,\\n            bool _distributionDisabled,\\n            bool _claimingDisabled,\\n            uint128 _totalAssignedRewards,\\n            uint128 _totalDistributedRewards,\\n            uint128 _totalClaimedRewards,\\n            uint128 _totalUnassignedUnclaimedRewards,\\n            uint256[] memory _monthsWithRewards\\n        );\\n\\n    /**\\n     * Gets the rewards information of a project for a given month.\\n     * @param _projectId The id of the project.\\n     * @param _month The month of the rewards.\\n     * @return _assignedRewards The amount of rewards assigned to the project for the month (in wei).\\n     * @return _distributedRewards The amount of rewards distributed by the project for the month (in wei).\\n     * @return _claimedRewards The amount of rewards claimed from the project for the month (in wei).\\n     * @return _unassignedUnclaimedRewards The amount of unassigned unclaimed rewards for the month (in wei).\\n     */\\n    function getProjectRewardsInfo(uint256 _projectId, uint256 _month)\\n        external view\\n        returns (\\n            uint128 _assignedRewards,\\n            uint128 _distributedRewards,\\n            uint128 _claimedRewards,\\n            uint128 _unassignedUnclaimedRewards\\n        );\\n\\n    /**\\n     * Gets the rewards information of a project for a given month and owner.\\n     * @param _projectId The id of the project.\\n     * @param _month The month of the rewards.\\n     * @param _owner The address of the owner.\\n     * @return _assignedRewards The amount of rewards assigned to the owner for the month (in wei).\\n     * @return _claimedRewards The amount of rewards claimed by the owner for the month (in wei).\\n     * @return _claimable Whether the rewards are claimable by the owner.\\n     */\\n    function getOwnerRewardsInfo(uint256 _projectId, uint256 _month, address _owner)\\n        external view\\n        returns (\\n            uint128 _assignedRewards,\\n            uint128 _claimedRewards,\\n            bool _claimable\\n        );\\n\\n    /**\\n     * Gets the claimable rewards of a project for a given owner.\\n     * @param _projectId The id of the project.\\n     * @param _owner The address of the owner.\\n     * @return The amount of rewards claimable by the owner (in wei).\\n     */\\n    function getClaimableRewards(uint256 _projectId, address _owner) external view returns (uint128);\\n\\n    /**\\n     * Gets owner's balances of `WNat`, `RNat` and locked tokens.\\n     * @param _owner The address of the owner.\\n     * @return _wNatBalance The balance of `WNat` (in wei).\\n     * @return _rNatBalance The balance of `RNat` (in wei).\\n     * @return _lockedBalance The locked/vested balance (in wei).\\n     */\\n    function getBalancesOf(\\n        address _owner\\n    )\\n        external view\\n        returns (\\n            uint256 _wNatBalance,\\n            uint256 _rNatBalance,\\n            uint256 _lockedBalance\\n        );\\n\\n    /**\\n     * Gets totals rewards information.\\n     * @return _totalAssignableRewards The total amount of assignable rewards (in wei).\\n     * @return _totalAssignedRewards The total amount of assigned rewards (in wei).\\n     * @return _totalClaimedRewards The total amount of claimed rewards (in wei).\\n     * @return _totalWithdrawnRewards The total amount of withdrawn rewards (in wei).\\n     * @return _totalWithdrawnAssignableRewards The total amount of withdrawn once assignable rewards (in wei).\\n     */\\n    function getRewardsInfo()\\n        external view\\n        returns (\\n            uint256 _totalAssignableRewards,\\n            uint256 _totalAssignedRewards,\\n            uint256 _totalClaimedRewards,\\n            uint256 _totalWithdrawnRewards,\\n            uint256 _totalWithdrawnAssignableRewards\\n        );\\n}\",\"keccak256\":\"0xedcf9a59299c5c7a8076af3851908864ce738a6fd2fb2aafbc512b613014bf45\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRNatAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRNat.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRNatAccount {\\n\\n    event FundsWithdrawn(uint256 amount, bool wrap);\\n    event LockedAmountBurned(uint256 amount);\\n    event ExternalTokenTransferred(IERC20 token, uint256 amount);\\n    event Initialized(address owner, IRNat rNat);\\n    event ClaimExecutorsSet(address[] executors);\\n\\n    /**\\n     * Returns the owner of the contract.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * Returns the `RNat` contract.\\n     */\\n    function rNat() external view returns (IRNat);\\n\\n    /**\\n     * Returns the total amount of rewards received ever.\\n     */\\n    function receivedRewards() external view returns (uint128);\\n\\n    /**\\n     * Returns the total amount of rewards withdrawn ever.\\n     */\\n    function withdrawnRewards() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0xcf897fa960f27fc8afd65be6c31b72bed16afd7c27d38d7d0d3ef3eeb3785faf\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRandomProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random provider interface.\\n */\\ninterface IRandomProvider {\\n\\n\\n    /**\\n     * Returns current random number. Method reverts if random number was not generated securely.\\n     * @return _randomNumber Current random number.\\n     */\\n    function getCurrentRandom() external view returns(uint256 _randomNumber);\\n\\n    /**\\n     * Returns current random number and a flag indicating if it was securely generated.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     */\\n    function getCurrentRandomWithQuality() external view returns(uint256 _randomNumber, bool _isSecureRandom);\\n\\n    /**\\n     * Returns current random number, a flag indicating if it was securely generated and its timestamp.\\n     * It is up to the caller to decide whether to use the returned random number or not.\\n     * @return _randomNumber Current random number.\\n     * @return _isSecureRandom Indicates if current random number is secure.\\n     * @return _randomTimestamp Random timestamp.\\n     */\\n    function getCurrentRandomWithQualityAndTimestamp()\\n        external view\\n        returns(uint256 _randomNumber, bool _isSecureRandom, uint256 _randomTimestamp);\\n}\\n\",\"keccak256\":\"0x1dc9b6fbeb006270a1cc1a7503f50bcb81e113f3d8d441b820bdac02a9f4c8bf\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistence.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IReferencedPaymentNonexistence\\n * @custom:id 0x04\\n * @custom:supported BTC, DOGE, XRP\\n * @author Flare\\n * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.\\n * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)\\n * did not appear in the specified block range.\\n *\\n *\\n * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart\\n * contract on Flare when a payment is missed.\\n *\\n * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient\\n * number of confirmations, the attestation request is rejected.\\n * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.\\n * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\\n * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,\\n * the attestation request is rejected.\\n *\\n * The request is confirmed if no transaction meeting the specified criteria is found in the search range.\\n * The criteria and timestamp are chain specific.\\n * ### UTXO (Bitcoin and Dogecoin)\\n *\\n *\\n * Criteria for the transaction:\\n *\\n *\\n * - It is not coinbase transaction.\\n * - The transaction has the specified standardPaymentReference.\\n * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with\\n * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the\\n * specified address is zero).\\n *\\n *\\n * Timestamp is `mediantime`.\\n * ### XRPL\\n *\\n *\\n *\\n * Criteria for the transaction:\\n * - The transaction is of type payment.\\n * - The transaction has the specified standardPaymentReference,\\n * - One of the following is true:\\n *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is\\n * greater than the specified `value`.\\n *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an\\n * amount greater than the specified `value` had the transaction been successful.\\n *\\n *\\n * Timestamp is `close_time` converted to UNIX time.\\n *\\n * @custom:lut `minimalBlockTimestamp`\\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\\n */\\ninterface IReferencedPaymentNonexistence {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction of the response\\n     * body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for ReferencePaymentNonexistence attestation type\\n     * @param minimalBlockNumber The start block of the search range.\\n     * @param deadlineBlockNumber The blockNumber to be included in the search range.\\n     * @param deadlineTimestamp The timestamp to be included in the search range.\\n     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.\\n     * @param amount The requested amount in minimal units that had to be payed.\\n     * @param standardPaymentReference The requested standard payment reference.\\n     * @param checkSourceAddresses If true, the source address root is checked (only full match).\\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\\n     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).\\n     */\\n    struct RequestBody {\\n        uint64 minimalBlockNumber;\\n        uint64 deadlineBlockNumber;\\n        uint64 deadlineTimestamp;\\n        bytes32 destinationAddressHash;\\n        uint256 amount;\\n        bytes32 standardPaymentReference;\\n        bool checkSourceAddresses;\\n        bytes32 sourceAddressesRoot;\\n    }\\n\\n    /**\\n     * @notice Response body for ReferencePaymentNonexistence attestation type.\\n     * @param minimalBlockTimestamp The timestamp of the minimalBlock.\\n     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.\\n     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.\\n     * @custom:below `firstOverflowBlock` is the first block that has block number higher than\\n     * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.\\n     * The specified search range are blocks between heights including `minimalBlockNumber`\\n     * and excluding `firstOverflowBlockNumber`.\\n     */\\n    struct ResponseBody {\\n        uint64 minimalBlockTimestamp;\\n        uint64 firstOverflowBlockNumber;\\n        uint64 firstOverflowBlockTimestamp;\\n    }\\n}\\n\",\"keccak256\":\"0x9ae917e75a27796c4ce2034ad24ddf916d396a003e5bb96aeec50c5b259dcd91\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistenceVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IReferencedPaymentNonexistence.sol\\\";\\n\\ninterface IReferencedPaymentNonexistenceVerification {\\n    function verifyReferencedPaymentNonexistence(IReferencedPaymentNonexistence.Proof calldata _proof)\\n        external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0xc6ad4b068bd041821834ff0ba3e1406402671cb17ff6dd97d63efc937c9a6476\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRelay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RandomNumberV2Interface.sol\\\";\\n\\n/**\\n * Relay interface.\\n */\\ninterface IRelay is RandomNumberV2Interface {\\n\\n    struct FeeConfig {\\n        uint8 protocolId;   // Protocol id for which the fee is set\\n        uint256 feeInWei;   // Fee in wei\\n    }\\n\\n    struct RelayInitialConfig {\\n        uint32 initialRewardEpochId;                           // The initial reward epoch id.\\n        uint32 startingVotingRoundIdForInitialRewardEpochId;   // The starting voting round id for the initial\\n                                                               // reward epoch.\\n        bytes32 initialSigningPolicyHash;                      // The initial signing policy hash.\\n        uint8 randomNumberProtocolId;                          // The protocol id of the random number protocol.\\n        uint32 firstVotingRoundStartTs;                        // The timestamp of the first voting round start.\\n        uint8 votingEpochDurationSeconds;                      // The duration of a voting epoch in seconds.\\n        uint32 firstRewardEpochStartVotingRoundId;             // The start voting round id of the first reward epoch.\\n        uint16 rewardEpochDurationInVotingEpochs;              // The duration of a reward epoch in voting epochs.\\n        uint16 thresholdIncreaseBIPS;                          // The threshold increase in BIPS for signing with\\n                                                               // old signing policy.\\n        uint32 messageFinalizationWindowInRewardEpochs;        // The window of reward epochs for finalizing\\n                                                               // the protocol messages.\\n        address payable feeCollectionAddress;                  // Fee collection address\\n        FeeConfig[] feeConfigs;                                // Fee configurations\\n    }\\n\\n    struct RelayGovernanceConfig {\\n        bytes32 descriptionHash;        // Description hash (should be keccak256(\\\"RelayGovernance\\\")\\n        uint256 chainId;                // Chain id on which is the relay is deployed\\n        FeeConfig[] newFeeConfigs;      // Fee configurations\\n    }\\n\\n    // Event is emitted when a new signing policy is initialized by the signing policy setter.\\n    event SigningPolicyInitialized(\\n        uint24 indexed rewardEpochId,   // Reward epoch id\\n        uint32 startVotingRoundId,      // First voting round id of validity.\\n                                        // Usually it is the first voting round of reward epoch rewardEpochId.\\n                                        // It can be later,\\n                                        // if the confirmation of the signing policy on Flare blockchain gets delayed.\\n        uint16 threshold,               // Confirmation threshold (absolute value of noramalised weights).\\n        uint256 seed,                   // Random seed.\\n        address[] voters,               // The list of eligible voters in the canonical order.\\n        uint16[] weights,               // The corresponding list of normalised signing weights of eligible voters.\\n                                        // Normalisation is done by compressing the weights from 32-byte values to\\n                                        // 2 bytes, while approximately keeping the weight relations.\\n        bytes signingPolicyBytes,       // The full signing policy byte encoded.\\n        uint64 timestamp                // Timestamp when this happened\\n    );\\n\\n    // Event is emitted when a signing policy is relayed.\\n    // It contains minimalistic data in order to save gas. Data about the signing policy are\\n    // extractable from the calldata, assuming prefered usage of direct top-level call to relay().\\n    event SigningPolicyRelayed(\\n        uint256 indexed rewardEpochId        // Reward epoch id\\n    );\\n\\n    // Event is emitted when a protocol message is relayed.\\n    event ProtocolMessageRelayed(\\n        uint8 indexed protocolId,           // Protocol id\\n        uint32 indexed votingRoundId,       // Voting round id\\n        bool isSecureRandom,                // Secure random flag\\n        bytes32 merkleRoot                  // Merkle root of the protocol message\\n    );\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures for the _messageHash\\n     * signed for protocol message Merkle root of the form (1, 0, 0, _messageHash).\\n     * If the check is successful, reward epoch id of the signing policy is returned.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _messageHash The hash of the message.\\n     * @return _rewardEpochId The reward epoch id of the signing policy.\\n     */\\n    function verifyCustomSignature(\\n        bytes calldata _relayMessage,\\n        bytes32 _messageHash\\n    )\\n        external\\n        returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Checks the relay message for sufficient weight of signatures of the hash of the _config data.\\n     * If the check is successful, the relay contract is configured with the new _config data, which\\n     * in particular means that fee configurations are updated.\\n     * Otherwise the function reverts.\\n     * @param _relayMessage The relay message.\\n     * @param _config The new relay configuration.\\n     */\\n    function governanceFeeSetup(bytes calldata _relayMessage, RelayGovernanceConfig calldata _config) external;\\n\\n    /**\\n     * Finalization function for new signing policies and protocol messages.\\n     * It can be used as finalization contract on Flare chain or as relay contract on other EVM chain.\\n     * Can be called in two modes. It expects calldata that is parsed in a custom manner.\\n     * Hence the transaction calls should assemble relevant calldata in the 'data' field.\\n     * Depending on the data provided, the contract operations in essentially two modes:\\n     * (1) Relaying signing policy. The structure of the calldata is:\\n     *        function signature (4 bytes) + active signing policy\\n     *             + 0 (1 byte) + new signing policy,\\n     *     total of exactly 4423 bytes.\\n     * (2) Relaying signed message. The structure of the calldata is:\\n     *        function signature (4 bytes) + signing policy\\n     *           + signed message (38 bytes) + ECDSA signatures with indices (67 bytes each)\\n     *     This case splits into two subcases:\\n     *     - protocolMessageId = 1: Message id must be of the form (protocolMessageId, 0, 0, merkleRoot).\\n     *       The validity of the signatures of sufficient weight is checked and if\\n     *       successful, the merkleRoot from the message is returned (32 bytes) and the\\n     *       reward epoch id of the signing policy as well (additional 3 bytes)\\n     *     - protocolMessageId > 1: The validity of the signatures of sufficient weight is checked and if\\n     *       it is valid, the merkleRoot is published for protocolId and votingRoundId.\\n     * Reverts if relaying is not successful.\\n     */\\n    function relay() external returns (bytes memory);\\n\\n    /**\\n     * Verifies the leaf (or intermediate node) with the Merkle proof against the Merkle root\\n     * for given protocol id and voting round id.\\n     * A fee may need to be paid. It is protocol specific.\\n     * **NOTE:** Overpayment is not refunded.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @param _leaf The leaf (or intermediate node) to verify.\\n     * @param _proof The Merkle proof.\\n     * @return True if the verification is successful.\\n     */\\n    function verify(uint256 _protocolId, uint256 _votingRoundId, bytes32 _leaf, bytes32[] calldata _proof)\\n        external payable\\n        returns (bool);\\n\\n    /**\\n     * Returns the signing policy hash for given reward epoch id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _signingPolicyHash The signing policy hash.\\n     */\\n    function toSigningPolicyHash(uint256 _rewardEpochId) external view returns (bytes32 _signingPolicyHash);\\n\\n    /**\\n     * Returns true if there is finalization for a given protocol id and voting round id.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     */\\n    function isFinalized(uint256 _protocolId, uint256 _votingRoundId) external view returns (bool);\\n\\n    /**\\n     * Returns the Merkle root for given protocol id and voting round id.\\n     * The function is reverted if signingPolicySetter is set, hence on all\\n     * deployments where the contract is used as a pure relay.\\n     * @param _protocolId The protocol id.\\n     * @param _votingRoundId The voting round id.\\n     * @return _merkleRoot The Merkle root.\\n     */\\n    function merkleRoots(uint256 _protocolId, uint256 _votingRoundId) external view returns (bytes32 _merkleRoot);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     * @param _rewardEpochId The reward epoch id.\\n     * @return _startingVotingRoundId The start voting round id.\\n     */\\n    function startingVotingRoundIds(uint256 _rewardEpochId) external view returns (uint256 _startingVotingRoundId);\\n\\n    /**\\n     * Returns the voting round id for given timestamp.\\n     * @param _timestamp The timestamp.\\n     * @return _votingRoundId The voting round id.\\n     */\\n    function getVotingRoundId(uint256 _timestamp) external view returns (uint256 _votingRoundId);\\n\\n    /**\\n     * Returns last initialized reward epoch data.\\n     * @return _lastInitializedRewardEpoch Last initialized reward epoch.\\n     * @return _startingVotingRoundIdForLastInitializedRewardEpoch Starting voting round id for it.\\n     */\\n    function lastInitializedRewardEpochData()\\n        external view\\n        returns (\\n            uint32 _lastInitializedRewardEpoch,\\n            uint32 _startingVotingRoundIdForLastInitializedRewardEpoch\\n        );\\n\\n    /**\\n     * Returns fee collection address.\\n     */\\n    function feeCollectionAddress() external view returns (address payable);\\n\\n    /**\\n     * Returns fee in wei for one verification of a given protocol id.\\n     * @param _protocolId The protocol id.\\n     */\\n    function protocolFeeInWei(uint256 _protocolId) external view returns (uint256);\\n\\n}\\n\",\"keccak256\":\"0x81598c5f3ae71afc5d8838125a3f26b5b928ae5a7fa911083381200f8a4f68cd\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IRewardManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./RewardsV2Interface.sol\\\";\\n\\n/**\\n * RewardManager interface.\\n */\\ninterface IRewardManager is RewardsV2Interface {\\n\\n    /// Struct used for storing unclaimed reward data.\\n    struct UnclaimedRewardState {\\n        bool initialised;           // Information if already initialised\\n                                    // amount and weight might be 0 if all users already claimed\\n        uint120 amount;             // Total unclaimed amount.\\n        uint128 weight;             // Total unclaimed weight.\\n    }\\n\\n    /**\\n     * Emitted when rewards are claimed.\\n     * @param beneficiary Address of the beneficiary (voter or node id) that accrued the reward.\\n     * @param rewardOwner Address that was eligible for the rewards.\\n     * @param recipient Address that received the reward.\\n     * @param rewardEpochId Id of the reward epoch where the reward was accrued.\\n     * @param claimType Claim type\\n     * @param amount Amount of rewarded native tokens (wei).\\n     */\\n    event RewardClaimed(\\n        address indexed beneficiary,\\n        address indexed rewardOwner,\\n        address indexed recipient,\\n        uint24 rewardEpochId,\\n        ClaimType claimType,\\n        uint120 amount\\n    );\\n\\n    /**\\n     * Unclaimed rewards have expired and are now inaccessible.\\n     *\\n     * `getUnclaimedRewardState()` can be used to retrieve more information.\\n     * @param rewardEpochId Id of the reward epoch that has just expired.\\n     */\\n    event RewardClaimsExpired(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Emitted when reward claims have been enabled.\\n     * @param rewardEpochId First claimable reward epoch.\\n     */\\n    event RewardClaimsEnabled(uint256 indexed rewardEpochId);\\n\\n    /**\\n     * Claim rewards for `_rewardOwners` and their PDAs.\\n     * Rewards are deposited to the WNAT (to reward owner or PDA if enabled).\\n     * It can be called by reward owner or its authorized executor.\\n     * Only claiming from weight based claims is supported.\\n     * @param _rewardOwners Array of reward owners.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function autoClaim(\\n        address[] calldata _rewardOwners,\\n        uint24 _rewardEpochId,\\n        RewardClaimWithProof[] calldata _proofs\\n    )\\n        external;\\n\\n    /**\\n     * Initialises weight based claims.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     */\\n    function initialiseWeightBasedClaims(RewardClaimWithProof[] calldata _proofs) external;\\n\\n    /**\\n     * Returns the reward manager id.\\n     */\\n    function rewardManagerId() external view returns (uint256);\\n\\n    /**\\n     * Returns the number of weight based claims that have been initialised.\\n     * @param _rewardEpochId Reward epoch id.\\n     */\\n    function noOfInitialisedWeightBasedClaims(uint256 _rewardEpochId) external view returns (uint256);\\n\\n    /**\\n     * Get the current cleanup block number.\\n     * @return The currently set cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address at a specific reward epoch.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewardsAt(\\n        address _rewardOwner,\\n        uint24 _rewardEpochId\\n    )\\n        external view\\n        returns (\\n            RewardState[] memory _rewardStates\\n        );\\n\\n    /**\\n     * Gets the unclaimed reward state for a beneficiary, reward epoch id and claim type.\\n     * @param _beneficiary Address of the beneficiary to query.\\n     * @param _rewardEpochId Id of the reward epoch to query.\\n     * @param _claimType Claim type to query.\\n     * @return _state Unclaimed reward state.\\n     */\\n    function getUnclaimedRewardState(\\n        address _beneficiary,\\n        uint24 _rewardEpochId,\\n        ClaimType _claimType\\n    )\\n        external view\\n        returns (\\n            UnclaimedRewardState memory _state\\n        );\\n\\n    /**\\n     * Returns totals.\\n     * @return _totalRewardsWei Total rewards (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards (wei).\\n     * @return _totalClaimedWei Total claimed rewards (wei).\\n     * @return _totalBurnedWei Total burned rewards (wei).\\n     */\\n    function getTotals()\\n        external view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _totalClaimedWei,\\n            uint256 _totalBurnedWei\\n        );\\n\\n    /**\\n     * Returns reward epoch totals.\\n     * @param _rewardEpochId Reward epoch id.\\n     * @return _totalRewardsWei Total rewards (inflation + community) for the epoch (wei).\\n     * @return _totalInflationRewardsWei Total inflation rewards for the epoch (wei).\\n     * @return _initialisedRewardsWei Initialised rewards of all claim types for the epoch (wei).\\n     * @return _claimedRewardsWei Claimed rewards for the epoch (wei).\\n     * @return _burnedRewardsWei Burned rewards for the epoch (wei).\\n     */\\n    function getRewardEpochTotals(uint24 _rewardEpochId)\\n        external view\\n        returns (\\n            uint256 _totalRewardsWei,\\n            uint256 _totalInflationRewardsWei,\\n            uint256 _initialisedRewardsWei,\\n            uint256 _claimedRewardsWei,\\n            uint256 _burnedRewardsWei\\n        );\\n\\n     /**\\n     * Returns current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns (uint24);\\n\\n    /**\\n     * Returns initial reward epoch id.\\n     */\\n    function getInitialRewardEpochId() external view returns (uint256);\\n\\n    /**\\n     * Returns the reward epoch id that will expire next once a new reward epoch starts.\\n     */\\n    function getRewardEpochIdToExpireNext() external view returns (uint256);\\n\\n    /**\\n     * The first reward epoch id that was claimable.\\n     */\\n    function firstClaimableRewardEpochId() external view returns (uint24);\\n}\\n\",\"keccak256\":\"0x6e601299c6eeedb167a2671a7587c3bbf290fcb78ec8f4a7a8ad86e6f6bcae74\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISortition.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {G1Point} from \\\"./IBn256.sol\\\";\\n\\nstruct SortitionCredential {\\n  uint256 replicate;\\n  G1Point gamma;\\n  uint256 c;\\n  uint256 s;\\n}\\n\",\"keccak256\":\"0xce8eac4878a9af3a2aea4f4dc74995358de06a0d3b937ad84d3fe98b953c0a6c\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ISubmission.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IRandomProvider.sol\\\";\\n\\n/**\\n * Submission interface.\\n */\\ninterface ISubmission is IRandomProvider {\\n\\n    /// Event emitted when a new voting round is initiated.\\n    event NewVotingRoundInitiated();\\n\\n    /**\\n     * Submit1 method. Used in multiple protocols (i.e. as FTSO commit method).\\n     */\\n    function submit1() external returns (bool);\\n\\n    /**\\n     * Submit2 method. Used in multiple protocols (i.e. as FTSO reveal method).\\n     */\\n    function submit2() external returns (bool);\\n\\n    /**\\n     * Submit3 method. Future usage.\\n     */\\n    function submit3() external returns (bool);\\n\\n    /**\\n     * SubmitSignatures method. Used in multiple protocols (i.e. as FTSO submit signature method).\\n     */\\n    function submitSignatures() external returns (bool);\\n\\n    /**\\n     * SubmitAndPass method. Future usage.\\n     * @param _data The data to pass to the submitAndPassContract.\\n     */\\n    function submitAndPass(bytes calldata _data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x86781d53b5fbecedad353ccfad5c6fe9485626e2454dd888f8973a1bd7dc66a4\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPContractEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVPContractEvents {\\n    /**\\n     * Event triggered when an account delegates or undelegates another account. \\n     * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.\\n     * For undelegation, `newVotePower` is 0.\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract`.\\n     */\\n    event Delegate(address indexed from, address indexed to, uint256 priorVotePower, uint256 newVotePower);\\n    \\n    /**\\n     * Event triggered only when account `delegator` revokes delegation to `delegatee`\\n     * for a single block in the past (typically the current vote block).\\n     *\\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.\\n     */\\n    event Revoke(address indexed delegator, address indexed delegatee, uint256 votePower, uint256 blockNumber);\\n}\\n\",\"keccak256\":\"0x651a2ff1d5c179b87259f564d02877ae496b236bd48f4813a4d815c25e2407cf\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IGovernanceVotePower} from \\\"./IGovernanceVotePower.sol\\\";\\nimport {IVPContractEvents} from \\\"./IVPContractEvents.sol\\\";\\n\\ninterface IVPToken is IERC20 {\\n    /**\\n     * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/\\n    function delegate(address _to, uint256 _bips) external;\\n    \\n    /**\\n     * @notice Undelegate all percentage delegations from the sender and then delegate corresponding \\n     *   `_bips` percentage of voting power from the sender to each member of `_delegatees`.\\n     * @param _delegatees The addresses of the new recipients.\\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Total of all `_bips` values must be at most 10000.\\n     **/\\n    function batchDelegate(address[] memory _delegatees, uint256[] memory _bips) external;\\n        \\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _to The address of the recipient\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/    \\n    function delegateExplicit(address _to, uint _amount) external;\\n\\n    /**\\n    * @notice Revoke all delegation from sender to `_who` at given block. \\n    *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n    *    Block `_blockNumber` must be in the past. \\n    *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n    *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n    * @param _who Address of the delegatee\\n    * @param _blockNumber The block number at which to revoke delegation.\\n    */\\n    function revokeDelegationAt(address _who, uint _blockNumber) external;\\n    \\n    /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     **/\\n    function undelegateAll() external;\\n    \\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(address[] memory _delegateAddresses) external returns (uint256);\\n\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Should be compatible with ERC20 method\\n     */\\n    function decimals() external view returns (uint8);\\n    \\n\\n    /**\\n     * @notice Total amount of tokens at a specific `_blockNumber`.\\n     * @param _blockNumber The block number when the totalSupply is queried\\n     * @return The total amount of tokens at `_blockNumber`\\n     **/\\n    function totalSupplyAt(uint _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.\\n     * @param _owner The address from which the balance will be retrieved.\\n     * @param _blockNumber The block number when the balance is queried.\\n     * @return The balance at `_blockNumber`.\\n     **/\\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint256);\\n\\n    \\n    /**\\n     * @notice Get the current total vote power.\\n     * @return The current total vote power (sum of all accounts' vote powers).\\n     */\\n    function totalVotePower() external view returns(uint256);\\n    \\n    /**\\n    * @notice Get the total vote power at block `_blockNumber`\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The total vote power at the block  (sum of all accounts' vote powers).\\n    */\\n    function totalVotePowerAt(uint _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the current vote power of `_owner`.\\n     * @param _owner The address to get voting power.\\n     * @return Current vote power of `_owner`.\\n     */\\n    function votePowerOf(address _owner) external view returns(uint256);\\n    \\n    /**\\n    * @notice Get the vote power of `_owner` at block `_blockNumber`\\n    * @param _owner The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_owner` at `_blockNumber`.\\n    */\\n    function votePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n    * @notice Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).\\n    * @param _owner The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_owner` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n    */\\n    function votePowerOfAtIgnoringRevocation(address _owner, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value. Once the delegation mode is set, \\n     *  it never changes, even if all delegations are removed.\\n     * @param _who The address to get delegation mode.\\n     * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)\\n     */\\n    function delegationModeOf(address _who) external view returns(uint256);\\n        \\n    /**\\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n    * @param _from Address of delegator\\n    * @param _to Address of delegatee\\n    * @return The delegated vote power.\\n    */\\n    function votePowerFromTo(address _from, address _to) external view returns(uint256);\\n    \\n    /**\\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n    * @param _from Address of delegator\\n    * @param _to Address of delegatee\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The delegated vote power.\\n    */\\n    function votePowerFromToAt(address _from, address _to, uint _blockNumber) external view returns(uint256);\\n    \\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(address _owner) external view returns(uint256);\\n    \\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\\n    \\n    /**\\n    * @notice Get the vote power delegation `delegationAddresses` \\n    *  and `_bips` of `_who`. Returned in two separate positional arrays.\\n    * @param _who The address to get delegations.\\n    * @return _delegateAddresses Positional array of delegation addresses.\\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n    * @return _count The number of delegates.\\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n    */\\n    function delegatesOf(address _who)\\n        external view \\n        returns (\\n            address[] memory _delegateAddresses,\\n            uint256[] memory _bips,\\n            uint256 _count, \\n            uint256 _delegationMode\\n        );\\n        \\n    /**\\n    * @notice Get the vote power delegation `delegationAddresses` \\n    *  and `pcts` of `_who`. Returned in two separate positional arrays.\\n    * @param _who The address to get delegations.\\n    * @param _blockNumber The block for which we want to know the delegations.\\n    * @return _delegateAddresses Positional array of delegation addresses.\\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n    * @return _count The number of delegates.\\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n    */\\n    function delegatesOfAt(address _who, uint256 _blockNumber)\\n        external view \\n        returns (\\n            address[] memory _delegateAddresses, \\n            uint256[] memory _bips, \\n            uint256 _count, \\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * Returns VPContract used for readonly operations (view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before).\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls). \\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Revoke` only).\\n     */\\n    function readVotePowerContract() external view returns (IVPContractEvents);\\n\\n    /**\\n     * Returns VPContract used for state changing operations (non-view methods).\\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\\n     *\\n     * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`\\n     * except during upgrade from one VPContract to a new version (which should happen\\n     * rarely or never and will be anounced before). In the case of upgrade,\\n     * `writeVotePowerContract` will be replaced first to establish delegations, and\\n     * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.\\n     *\\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\\n     * via VPToken (and state changing methods are forbidden from direct calls). \\n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\\n     * for listening to events (`Delegate` and `Revoke` only).\\n     */\\n    function writeVotePowerContract() external view returns (IVPContractEvents);\\n    \\n    /**\\n     * When set, allows token owners to participate in governance voting\\n     * and delegate governance vote power.\\n     */\\n    function governanceVotePower() external view returns (IGovernanceVotePower);\\n}\\n\",\"keccak256\":\"0xa8755907f367ef19f960759730e3c17fa95b18ee01e38b98c82071805af21f2e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IValidatorRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\n/**\\n * @title Validator registry contract\\n * @notice This contract is used as a mapping from data provider's address to {node id, P-Chain public key}\\n * @notice In order to get the ability to become a validator, data provider must register using this contract\\n * @dev Only whitelisted data provider can register\\n */\\ninterface IValidatorRegistry {\\n\\n    event DataProviderRegistered(address indexed dataProvider, string nodeId, string pChainPublicKey);\\n    event DataProviderUnregistered(address indexed dataProvider);\\n\\n    /**\\n     * @notice Register data provider's address as a validator - emits DataProviderRegistered event\\n     * @param _nodeId Data provider's node id\\n     * @param _pChainPublicKey Data provider's P-Chain public key\\n     * @dev Data provider must be whitelisted\\n     * @dev `_nodeId` and `_pChainPublicKey` should not be already in use by some other data provider\\n     */\\n    function registerDataProvider(string memory _nodeId, string memory _pChainPublicKey) external;\\n\\n    /**\\n     * @notice Unregister data provider's address as a validator - emits DataProviderUnregistered event\\n     */\\n    function unregisterDataProvider() external;\\n\\n    /**\\n     * @notice Returns data provider's node id and P-Chain public key\\n     * @param _dataProvider Data provider's address\\n     * @return _nodeId Data provider's node id\\n     * @return _pChainPublicKey Data provider's P-Chain public key\\n     */\\n    function getDataProviderInfo(address _dataProvider)\\n        external view returns (string memory _nodeId, string memory _pChainPublicKey);\\n\\n    /**\\n     * @notice Returns data provider's address that was registered with given node id\\n     * @param _nodeId Data provider's node id hash\\n     * @return _dataProvider Data provider's address\\n     */\\n    function getDataProviderForNodeId(bytes32 _nodeId) \\n        external view returns (address _dataProvider);\\n\\n    /**\\n     * @notice Returns data provider's address that was registered with given P-Chain public key\\n     * @param _pChainPublicKey Data provider's P-Chain public key hash\\n     * @return _dataProvider Data provider's address\\n     */\\n    function getDataProviderForPChainPublicKey(bytes32 _pChainPublicKey) \\n        external view returns (address _dataProvider);\\n}\\n\",\"keccak256\":\"0x89745190d1d140ee49d354d92225e179f59907272b632891c5dc571014faa4a2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * VoterRegistry interface.\\n */\\ninterface IVoterRegistry {\\n\\n    /// Signature data.\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// Event emitted when a beneficiary (c-chain address or node id) is chilled.\\n    event BeneficiaryChilled(bytes20 indexed beneficiary, uint256 untilRewardEpochId);\\n\\n    /// Event emitted when a voter is removed.\\n    event VoterRemoved(address indexed voter, uint256 indexed rewardEpochId);\\n\\n    /// Event emitted when a voter is registered.\\n    event VoterRegistered(\\n        address indexed voter,\\n        uint24 indexed rewardEpochId,\\n        address indexed signingPolicyAddress,\\n        address submitAddress,\\n        address submitSignaturesAddress,\\n        bytes32 publicKeyPart1,\\n        bytes32 publicKeyPart2,\\n        uint256 registrationWeight\\n    );\\n\\n    /**\\n     * Registers a voter if the weight is high enough.\\n     * @param _voter The voter address.\\n     * @param _signature The signature.\\n     */\\n    function registerVoter(address _voter, Signature calldata _signature) external;\\n\\n    /**\\n     * Maximum number of voters in one reward epoch.\\n     */\\n    function maxVoters() external view returns (uint256);\\n\\n    /**\\n     * In case of providing bad votes (e.g. ftso collusion), the beneficiary can be chilled for a few reward epochs.\\n     * If beneficiary is chilled, the vote power assigned to it is zero.\\n     * @param _beneficiary The beneficiary (c-chain address or node id).\\n     * @return _rewardEpochId The reward epoch id until which the voter is chilled.\\n     */\\n    function chilledUntilRewardEpochId(bytes20 _beneficiary) external view returns (uint256 _rewardEpochId);\\n\\n    /**\\n     * Returns the block number of the start of the new signing policy initialisation for a given reward epoch.\\n     * It is a snaphost block of the voters' addresses (it is zero if the reward epoch is not supported).\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function newSigningPolicyInitializationStartBlockNumber(uint256 _rewardEpochId) external view returns (uint256);\\n\\n    /**\\n     * Indicates if the voter must have the public key set when registering.\\n     */\\n    function publicKeyRequired() external view returns (bool);\\n\\n    /**\\n     * Returns the list of registered voters for a given reward epoch.\\n     * List can be empty if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * List for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getRegisteredVoters(uint256 _rewardEpochId) external view returns (address[] memory);\\n\\n    /**\\n     * Returns the number of registered voters for a given reward epoch.\\n     * Size can be zero if the reward epoch is not supported (before initial reward epoch or future reward epoch).\\n     * Size for the next reward epoch can still change until the signing policy snapshot is created.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function getNumberOfRegisteredVoters(uint256 _rewardEpochId) external view returns (uint256);\\n\\n    /**\\n     * Returns true if a voter was (is currently) registered in a given reward epoch.\\n     * @param _voter The voter address.\\n     * @param _rewardEpochId The reward epoch id.\\n     */\\n    function isVoterRegistered(address _voter, uint256 _rewardEpochId) external view returns(bool);\\n}\\n\",\"keccak256\":\"0x61c3c9ac322108413d7c9b69f7e25077049090b8567b5b1397ce2392897f8198\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IVoterWhitelister.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IVoterWhitelister {\\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterWhitelisted(address voter, uint256 ftsoIndex);\\n    \\n    /**\\n     * Raised when an account is removed from the voter whitelist.\\n     */\\n    event VoterRemovedFromWhitelist(address voter, uint256 ftsoIndex);\\n\\n    /**\\n     * Raised when an account is chilled from the voter whitelist.\\n     */\\n    event VoterChilled(address voter, uint256 untilRewardEpoch);\\n\\n    /**\\n     * Request to whitelist `_voter` account to ftso at `_ftsoIndex`. Will revert if vote power too low.\\n     * May be called by any address.\\n     */\\n    function requestWhitelistingVoter(address _voter, uint256 _ftsoIndex) external;\\n\\n    /**\\n     * Request to whitelist `_voter` account to all active ftsos.\\n     * May be called by any address.\\n     * It returns an array of supported ftso indices and success flag per index.\\n     */\\n    function requestFullVoterWhitelisting(\\n        address _voter\\n    ) \\n        external \\n        returns (\\n            uint256[] memory _supportedIndices,\\n            bool[] memory _success\\n        );\\n\\n    /**\\n     * Maximum number of voters in the whitelist for a new FTSO.\\n     */\\n    function defaultMaxVotersForFtso() external view returns (uint256);\\n    \\n    /**\\n     * Maximum number of voters in the whitelist for FTSO at index `_ftsoIndex`.\\n     */\\n    function maxVotersForFtso(uint256 _ftsoIndex) external view returns (uint256);\\n\\n    /**\\n     * Get whitelisted price providers for ftso with `_symbol`\\n     */\\n    function getFtsoWhitelistedPriceProvidersBySymbol(string memory _symbol) external view returns (address[] memory);\\n\\n    /**\\n     * Get whitelisted price providers for ftso at `_ftsoIndex`\\n     */\\n    function getFtsoWhitelistedPriceProviders(uint256 _ftsoIndex) external view returns (address[] memory);\\n\\n    /**\\n     * In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs.\\n     * A voter can whitelist again from a returned reward epoch onwards.\\n     */\\n    function chilledUntilRewardEpoch(address _voter) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfaa76e4db7440304e5c1518e24b8c5008cbda90e30d31646f48346be20057669\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNat.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IVPToken.sol\\\";\\nimport \\\"./token/interface/IICleanable.sol\\\";\\n\\n\\n/**\\n * @title Wrapped Native token\\n * Accept native token deposits and mint ERC20 WNAT (wrapped native) tokens 1-1.\\n */\\ninterface IWNat is IVPToken, IICleanable {\\n    /**\\n     * Deposit Native and mint wNat ERC20.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * Deposit Native from msg.sender and mints WNAT ERC20 to recipient address.\\n     * @param recipient An address to receive minted WNAT.\\n     */\\n    function depositTo(address recipient) external payable;\\n\\n    /**\\n     * Withdraw Native and burn WNAT ERC20.\\n     * @param amount The amount to withdraw.\\n     */\\n    function withdraw(uint256 amount) external;\\n\\n    /**\\n     * Withdraw WNAT from an owner and send native tokens to msg.sender given an allowance.\\n     * @param owner An address spending the Native tokens.\\n     * @param amount The amount to spend.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `owners`'s tokens of at least\\n     * `amount`.\\n     */\\n    function withdrawFrom(address owner, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xed51c1c6b3a3f9f2390709583e70e7aaa4b4e32cf4a48bc7203d75fa9c755d2a\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWNatDelegationFee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * WNatDelegationFee interface.\\n */\\ninterface IWNatDelegationFee {\\n\\n    /// Event emitted when a voter fee percentage value is changed.\\n    event FeePercentageChanged(address indexed voter, uint16 value, uint24 validFromEpochId);\\n\\n    /**\\n     * Allows voter to set (or update last) fee percentage.\\n     * @param _feePercentageBIPS Number representing fee percentage in BIPS.\\n     * @return Returns the reward epoch number when the value becomes effective.\\n     */\\n    function setVoterFeePercentage(uint16 _feePercentageBIPS) external returns (uint256);\\n\\n    /// The offset in reward epochs for the fee percentage value to become effective.\\n    function feePercentageUpdateOffset() external view returns (uint24);\\n\\n    /// The default fee percentage value.\\n    function defaultFeePercentageBIPS() external view returns (uint16);\\n\\n    /**\\n     * Returns the current fee percentage of `_voter`.\\n     * @param _voter Voter address.\\n     */\\n    function getVoterCurrentFeePercentage(address _voter) external view returns (uint16);\\n\\n    /**\\n     * Returns the fee percentage of `_voter` for given reward epoch id.\\n     * @param _voter Voter address.\\n     * @param _rewardEpochId Reward epoch id.\\n     * **NOTE:** fee percentage might still change for the `current + feePercentageUpdateOffset` reward epoch id\\n     */\\n    function getVoterFeePercentage(\\n        address _voter,\\n        uint256 _rewardEpochId\\n    )\\n        external view\\n        returns (uint16);\\n\\n    /**\\n     * Returns the scheduled fee percentage changes of `_voter`.\\n     * @param _voter Voter address.\\n     * @return _feePercentageBIPS Positional array of fee percentages in BIPS.\\n     * @return _validFromEpochId Positional array of reward epoch ids the fee setings are effective from.\\n     * @return _fixed Positional array of boolean values indicating if settings are subjected to change.\\n     */\\n    function getVoterScheduledFeePercentageChanges(\\n        address _voter\\n    )\\n        external view\\n        returns (\\n            uint256[] memory _feePercentageBIPS,\\n            uint256[] memory _validFromEpochId,\\n            bool[] memory _fixed\\n        );\\n}\\n\",\"keccak256\":\"0xf1f4201d68272ee77c87571a07abae2bd521590774b8238dafce337b9405d9af\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * @custom:name IWeb2Json\\n * @custom:supported WEB2\\n * @author Flare\\n * @notice An attestation request that fetches JSON data from the given URL,\\n * applies a jq filter to transform the returned result, and returns the structured data as ABI encoded data.\\n * @custom:verification  Data is fetched from an URL `url`. The received data is then processed with jq as\\n * the `postProcessJq` states. The structure of the final JSON is written in the `abiSignature`.\\n *\\n * The response contains an abi encoding of the final data.\\n * @custom:lut `0xffffffffffffffff`\\n * @custom:lut-limit `0xffffffffffffffff`\\n */\\ninterface IWeb2Json {\\n    /**\\n     * @notice Toplevel request\\n     * @param attestationType ID of the attestation type.\\n     * @param sourceId ID of the data source.\\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\\n     * by the `attestationType`.\\n     */\\n    struct Request {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        bytes32 messageIntegrityCode;\\n        RequestBody requestBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel response\\n     * @param attestationType Extracted from the request.\\n     * @param sourceId Extracted from the request.\\n     * @param votingRound The ID of the State Connector round in which the request was considered.\\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\\n     * @param requestBody Extracted from the request.\\n     * @param responseBody Data defining the response. The verification rules for the construction\\n     * of the response body and the type are defined per specific `attestationType`.\\n     */\\n    struct Response {\\n        bytes32 attestationType;\\n        bytes32 sourceId;\\n        uint64 votingRound;\\n        uint64 lowestUsedTimestamp;\\n        RequestBody requestBody;\\n        ResponseBody responseBody;\\n    }\\n\\n    /**\\n     * @notice Toplevel proof\\n     * @param merkleProof Merkle proof corresponding to the attestation response.\\n     * @param data Attestation response.\\n     */\\n    struct Proof {\\n        bytes32[] merkleProof;\\n        Response data;\\n    }\\n\\n    /**\\n     * @notice Request body for Web2Json attestation type\\n     * @param url URL of the data source\\n     * @param httpMethod HTTP method to be used to fetch from URL source.\\n     * Supported methods: GET, POST, PUT, PATCH, DELETE.\\n     * @param headers Headers to be included to fetch from URL source. Use `{}` if no headers are needed.\\n     * @param queryParams Query parameters to be included to fetch from URL source.\\n     * Use `{}` if no query parameters are needed.\\n     * @param body Request body to be included to fetch from URL source. Use '{}' if no request body is required.\\n     * @param postProcessJq jq filter used to post-process the JSON response from the URL.\\n     * @param abiSignature ABI signature of the struct used to encode the data after jq post-processing.\\n     */\\n    struct RequestBody {\\n        string url;\\n        string httpMethod;\\n        string headers;\\n        string queryParams;\\n        string body;\\n        string postProcessJq;\\n        string abiSignature;\\n    }\\n\\n    /**\\n     * @notice Response body for Web2Json attestation type\\n     * @param abiEncodedData Raw binary data encoded to match the function parameters in ABI.\\n     */\\n    struct ResponseBody {\\n        bytes abiEncodedData;\\n    }\\n}\\n\",\"keccak256\":\"0xf6fe44b15d57a422378dd0cf7520df1df30cb2b81869b5d60857392e1362f66b\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/IWeb2JsonVerification.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IWeb2Json.sol\\\";\\n\\ninterface IWeb2JsonVerification {\\n    function verifyJsonApi(IWeb2Json.Proof calldata _proof) external view returns (bool _proved);\\n}\\n\",\"keccak256\":\"0x9cf4d5361bf78ba5221b47d59e75f70f3ab8da06a22a652361e325ff762e8a7d\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ProtocolsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Protocols V2 long term support interface.\\n */\\ninterface ProtocolsV2Interface {\\n\\n    /**\\n     * Timestamp when the first reward epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstRewardEpochStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of reward epoch, in seconds.\\n     */\\n    function rewardEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Timestamp when the first voting epoch started, in seconds since UNIX epoch.\\n     */\\n    function firstVotingRoundStartTs() external view returns (uint64);\\n\\n    /**\\n     * Duration of voting epoch, in seconds.\\n     */\\n    function votingEpochDurationSeconds() external view returns (uint64);\\n\\n    /**\\n     * Returns the vote power block for given reward epoch id.\\n     */\\n    function getVotePowerBlock(uint256 _rewardEpochId)\\n        external view\\n        returns(uint64 _votePowerBlock);\\n\\n    /**\\n     * Returns the start voting round id for given reward epoch id.\\n     */\\n    function getStartVotingRoundId(uint256 _rewardEpochId)\\n        external view\\n        returns(uint32);\\n\\n    /**\\n     * Returns the current reward epoch id.\\n     */\\n    function getCurrentRewardEpochId() external view returns(uint24);\\n\\n    /**\\n     * Returns the current voting epoch id.\\n     */\\n    function getCurrentVotingEpochId() external view returns(uint32);\\n\\n}\",\"keccak256\":\"0x048269637b12d8a90f8319a1430b4d3dc3b85d48c2beaf7dfff3c288ea0839db\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Random number V2 long term support interface.\\n */\\ninterface RandomNumberV2Interface {\\n    /**\\n     * Returns the current random number, its timestamp and the flag indicating if it is secure.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumber()\\n        external view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n\\n    /**\\n     * Returns the historical random number for a given _votingRoundId,\\n     * its timestamp and the flag indicating if it is secure.\\n     * If no finalization in the _votingRoundId, the function reverts.\\n     * @param _votingRoundId The voting round id.\\n     * @return _randomNumber The current random number.\\n     * @return _isSecureRandom The flag indicating if the random number is secure.\\n     * @return _randomTimestamp The timestamp of the random number.\\n     */\\n    function getRandomNumberHistorical(uint256 _votingRoundId)\\n        external view\\n        returns (\\n            uint256 _randomNumber,\\n            bool _isSecureRandom,\\n            uint256 _randomTimestamp\\n        );\\n}\",\"keccak256\":\"0xc35805236772520b075fb386d7967eaf6dd45e5d5bac6a514e932f90ad32924e\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/RewardsV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * Rewards V2 long term support interface.\\n */\\ninterface RewardsV2Interface {\\n\\n    /// Claim type enum.\\n    enum ClaimType { DIRECT, FEE, WNAT, MIRROR, CCHAIN }\\n\\n   /// Struct used for claiming rewards with Merkle proof.\\n    struct RewardClaimWithProof {\\n        bytes32[] merkleProof;\\n        RewardClaim body;\\n    }\\n\\n    /// Struct used in Merkle tree for storing reward claims.\\n    struct RewardClaim {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n    }\\n\\n    /// Struct used for returning state of rewards.\\n    struct RewardState {\\n        uint24 rewardEpochId;\\n        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR\\n        uint120 amount; // in wei\\n        ClaimType claimType;\\n        bool initialised;\\n    }\\n\\n    /**\\n     * Claim rewards for `_rewardOwner` and transfer them to `_recipient`.\\n     * It can be called by reward owner or its authorized executor.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @param _recipient Address of the reward recipient.\\n     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.\\n     * @param _wrap Indicates if the reward should be wrapped (deposited) to the WNAT contract.\\n     * @param _proofs Array of reward claims with merkle proofs.\\n     * @return _rewardAmountWei Amount of rewarded native tokens (wei).\\n     */\\n    function claim(\\n        address _rewardOwner,\\n        address payable _recipient,\\n        uint24 _rewardEpochId,\\n        bool _wrap,\\n        RewardClaimWithProof[] calldata _proofs\\n    )\\n        external\\n        returns (uint256 _rewardAmountWei);\\n\\n    /**\\n     * Indicates if the contract is active - claims are enabled.\\n     */\\n    function active() external view returns (bool);\\n\\n    /**\\n     * Returns the start and the end of the reward epoch range for which the reward is claimable.\\n     * @return _startEpochId The oldest epoch id that allows reward claiming.\\n     * @return _endEpochId The newest epoch id that allows reward claiming.\\n     */\\n    function getRewardEpochIdsWithClaimableRewards()\\n        external view\\n        returns (\\n            uint24 _startEpochId,\\n            uint24 _endEpochId\\n        );\\n\\n    /**\\n     * Returns the next claimable reward epoch for a reward owner.\\n     * @param _rewardOwner Address of the reward owner to query.\\n     */\\n    function getNextClaimableRewardEpochId(address _rewardOwner) external view returns (uint256);\\n\\n    /**\\n     * Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.\\n     * @param _rewardOwner Address of the reward owner.\\n     * @return _rewardStates Array of reward states.\\n     */\\n    function getStateOfRewards(\\n        address _rewardOwner\\n    )\\n        external view\\n        returns (\\n            RewardState[][] memory _rewardStates\\n        );\\n\\n}\",\"keccak256\":\"0x448b3a425efbf66ce0200d202304143f6c3132868c2ef59c2cd39b2dad190ab2\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n/**\\n * FtsoV2 long term support interface.\\n */\\ninterface TestFtsoV2Interface {\\n\\n    /// Feed data structure\\n    struct FeedData {\\n        uint32 votingRoundId;\\n        bytes21 id;\\n        int32 value;\\n        uint16 turnoutBIPS;\\n        int8 decimals;\\n    }\\n\\n    /// Feed data with proof structure\\n    struct FeedDataWithProof {\\n        bytes32[] proof;\\n        FeedData body;\\n    }\\n\\n    /// Feed id change structure\\n    struct FeedIdChange {\\n        bytes21 oldFeedId;\\n        bytes21 newFeedId;\\n    }\\n\\n    /// Event emitted when a feed id is changed (e.g. feed renamed).\\n    event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);\\n\\n    /**\\n     * Returns the FTSO protocol id.\\n     */\\n    function getFtsoProtocolId() external view returns (uint256);\\n\\n    /**\\n     * Returns the list of supported feed ids (currently active feed ids).\\n     * To get the list of all available feed ids, combine with `getFeedIdChanges()`.\\n     * @return _feedIds The list of supported feed ids.\\n     */\\n    function getSupportedFeedIds() external view returns (bytes21[] memory _feedIds);\\n\\n    /**\\n     * Returns the list of feed id changes.\\n     * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).\\n     */\\n    function getFeedIdChanges() external view returns (FeedIdChange[] memory _feedIdChanges);\\n\\n    /**\\n     * Calculates the fee for fetching a feed.\\n     * @param _feedId The id of the feed.\\n     * @return _fee The fee for fetching the feed.\\n     */\\n    function calculateFeeById(bytes21 _feedId) external view returns (uint256 _fee);\\n\\n    /**\\n     * Calculates the fee for fetching feeds.\\n     * @param _feedIds The list of feed ids.\\n     * @return _fee The fee for fetching the feeds.\\n     */\\n    function calculateFeeByIds(bytes21[] memory _feedIds) external view returns (uint256 _fee);\\n\\n    /**\\n     * Returns stored data of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed.\\n     * @return _decimals The decimal places for the requested feed.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedById(bytes21 _feedId)\\n        external view\\n        returns (\\n            uint256 _value,\\n            int8 _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns stored data of each feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds The list of feed ids.\\n     * @return _values The list of values for the requested feeds.\\n     * @return _decimals The list of decimal places for the requested feeds.\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsById(bytes21[] memory _feedIds)\\n        external view\\n        returns (\\n            uint256[] memory _values,\\n            int8[] memory _decimals,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Returns value in wei and timestamp of a feed.\\n     * A fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedId The id of the feed.\\n     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedByIdInWei(bytes21 _feedId)\\n        external view\\n        returns (\\n            uint256 _value,\\n            uint64 _timestamp\\n        );\\n\\n    /** Returns value of each feed and a timestamp.\\n     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.\\n     * @param _feedIds Ids of the feeds.\\n     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).\\n     * @return _timestamp The timestamp of the last update.\\n     */\\n    function getFeedsByIdInWei(bytes21[] memory _feedIds)\\n        external view\\n        returns (\\n            uint256[] memory _values,\\n            uint64 _timestamp\\n        );\\n\\n    /**\\n     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).\\n     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.\\n     * @return true if the feed data is valid.\\n     */\\n    function verifyFeedData(FeedDataWithProof calldata _feedData) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x7db4b7fa9b90e0b388cc63d4b38f8b125e6343512853ff97a4dab7e4936a2ace\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/ftso/interface/IIFtso.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../genesis/interface/IFtsoGenesis.sol\\\";\\nimport \\\"../../IFtso.sol\\\";\\nimport \\\"../../token/interface/IIVPToken.sol\\\";\\n\\n\\ninterface IIFtso is IFtso, IFtsoGenesis {\\n\\n    /// function finalizePriceReveal\\n    /// called by reward manager only on correct timing.\\n    /// if price reveal period for epoch x ended. finalize.\\n    /// iterate list of price submissions\\n    /// find weighted median\\n    /// find adjucant 50% of price submissions.\\n    /// Allocate reward for any price submission which is same as a \\\"winning\\\" submission\\n    function finalizePriceEpoch(uint256 _epochId, bool _returnRewardData) external\\n        returns(\\n            address[] memory _eligibleAddresses,\\n            uint256[] memory _natWeights,\\n            uint256 _totalNatWeight\\n        );\\n\\n    function fallbackFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    function forceFinalizePriceEpoch(uint256 _epochId) external;\\n\\n    // activateFtso will be called by ftso manager once ftso is added \\n    // before this is done, FTSO can't run\\n    function activateFtso(\\n        uint256 _firstEpochStartTs,\\n        uint256 _submitPeriodSeconds,\\n        uint256 _revealPeriodSeconds\\n    ) external;\\n\\n    function deactivateFtso() external;\\n\\n    // update initial price and timestamp - only if not active\\n    function updateInitialPrice(uint256 _initialPriceUSD, uint256 _initialPriceTimestamp) external;\\n\\n    function configureEpochs(\\n        uint256 _maxVotePowerNatThresholdFraction,\\n        uint256 _maxVotePowerAssetThresholdFraction,\\n        uint256 _lowAssetUSDThreshold,\\n        uint256 _highAssetUSDThreshold,\\n        uint256 _highAssetTurnoutThresholdBIPS,\\n        uint256 _lowNatTurnoutThresholdBIPS,\\n        uint256 _elasticBandRewardBIPS,\\n        uint256 _elasticBandWidthPPM,\\n        address[] memory _trustedAddresses\\n    ) external;\\n\\n    function setAsset(IIVPToken _asset) external;\\n\\n    function setAssetFtsos(IIFtso[] memory _assetFtsos) external;\\n\\n    // current vote power block will update per reward epoch. \\n    // the FTSO doesn't have notion of reward epochs.\\n    // reward manager only can set this data. \\n    function setVotePowerBlock(uint256 _blockNumber) external;\\n\\n    function initializeCurrentEpochStateForReveal(uint256 _circulatingSupplyNat, bool _fallbackMode) external;\\n  \\n    /**\\n     * @notice Returns ftso manager address\\n     */\\n    function ftsoManager() external view returns (address);\\n\\n    /**\\n     * @notice Returns the FTSO asset\\n     * @dev Asset is null in case of multi-asset FTSO\\n     */\\n    function getAsset() external view returns (IIVPToken);\\n\\n    /**\\n     * @notice Returns the Asset FTSOs\\n     * @dev AssetFtsos is not null only in case of multi-asset FTSO\\n     */\\n    function getAssetFtsos() external view returns (IIFtso[] memory);\\n\\n    /**\\n     * @notice Returns current configuration of epoch state\\n     * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter\\n     * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter\\n     * @return _lowAssetUSDThreshold            Threshold for low asset vote power\\n     * @return _highAssetUSDThreshold           Threshold for high asset vote power\\n     * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout\\n     * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout\\n     * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the \\n        elastic band (prices within _elasticBandWidthPPM of the median) \\n        and 10000 - elasticBandRewardBIPS to the IQR \\n     * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded\\n     * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved\\n     */\\n    function epochsConfiguration() external view \\n        returns (\\n            uint256 _maxVotePowerNatThresholdFraction,\\n            uint256 _maxVotePowerAssetThresholdFraction,\\n            uint256 _lowAssetUSDThreshold,\\n            uint256 _highAssetUSDThreshold,\\n            uint256 _highAssetTurnoutThresholdBIPS,\\n            uint256 _lowNatTurnoutThresholdBIPS,\\n            uint256 _elasticBandRewardBIPS,\\n            uint256 _elasticBandWidthPPM,\\n            address[] memory _trustedAddresses\\n        );\\n\\n    /**\\n     * @notice Returns parameters necessary for approximately replicating vote weighting.\\n     * @return _assets                  the list of Assets that are accounted in vote\\n     * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA\\n     * @return _totalVotePowerNat       total native token vote power at block\\n     * @return _totalVotePowerAsset     total combined asset vote power at block\\n     * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)\\n     * @return _votePowerBlock          vote powewr block for given epoch\\n     */\\n    function getVoteWeightingParameters() external view \\n        returns (\\n            IIVPToken[] memory _assets,\\n            uint256[] memory _assetMultipliers,\\n            uint256 _totalVotePowerNat,\\n            uint256 _totalVotePowerAsset,\\n            uint256 _assetWeightRatio,\\n            uint256 _votePowerBlock\\n        );\\n\\n    function wNat() external view returns (IIVPToken);\\n}\\n\",\"keccak256\":\"0x11e1ee671aa92ed02724713553b1bffe7aa1a992844f8b26da6de2b67bb347ae\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interface/IFtsoGenesis.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\ninterface IFtsoGenesis {\\n\\n    /**\\n     * @notice Reveals submitted price during epoch reveal period - only price submitter\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @param _price                Submitted price in USD\\n     * @notice The hash of _price and _random must be equal to the submitted hash\\n     * @notice Emits PriceRevealed event\\n     */\\n    function revealPriceSubmitter(\\n        address _voter,\\n        uint256 _epochId,\\n        uint256 _price,\\n        uint256 _wNatVP\\n    ) external;\\n\\n    /**\\n     * @notice Get (and cache) wNat vote power for specified voter and given epoch id\\n     * @param _voter                Voter address\\n     * @param _epochId              Id of the epoch in which the price hash was submitted\\n     * @return wNat vote power\\n     */\\n    function wNatVotePowerCached(address _voter, uint256 _epochId) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xd015bc43b8a22afaba50c42a56409df0d81172845dabc124a3d37b3b0bbd4df5\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interface/IFtsoManagerGenesis.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\n\\ninterface IFtsoManagerGenesis {\\n\\n    function getCurrentPriceEpochId() external view returns (uint256 _priceEpochId);\\n\\n}\\n\",\"keccak256\":\"0xe3282e14304e70a34f6c7a6ee563267635a6cc6eff09f2459a43946ae3a113ab\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/genesis/interface/IFtsoRegistryGenesis.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"./IFtsoGenesis.sol\\\";\\n\\n\\ninterface IFtsoRegistryGenesis {\\n\\n    function getFtsos(uint256[] memory _indices) external view returns(IFtsoGenesis[] memory _ftsos);\\n}\\n\",\"keccak256\":\"0x4765fdcb22dcc64c015d02c019f0ddce8d8b36111160fd4160a3d94ea4f370a3\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interface/IICleanable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\ninterface IICleanable {\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n    \\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\\n     * history before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be before current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n    \\n    /**\\n     * Get the current cleanup block number.\\n     */\\n    function cleanupBlockNumber() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3ccc1532d642c3feff5b282a7c8901e2582844c1559acd1bd671afcb3aabaaef\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interface/IIGovernanceVotePower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IPChainStakeMirror.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\n\\n/**\\n * Internal interface for contracts delegating their governance vote power.\\n */\\ninterface IIGovernanceVotePower is IGovernanceVotePower {\\n    /**\\n     * Emitted when a delegate's vote power changes, as a result of a new delegation\\n     * or a token transfer, for example.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegate The account receiving the changing delegated vote power.\\n     * @param previousBalance Delegated vote power before the change.\\n     * @param newBalance Delegated vote power after the change.\\n     */\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    /**\\n     * Emitted when an account starts delegating vote power or switches its delegation\\n     * to another address.\\n     *\\n     * The event is always emitted from a `GovernanceVotePower` contract.\\n     * @param delegator Account delegating its vote power.\\n     * @param fromDelegate Account receiving the delegation before the change.\\n     * Can be address(0) if there was no previous delegation.\\n     * @param toDelegate Account receiving the delegation after the change.\\n     * Can be address(0) if `delegator` just undelegated all its vote power.\\n     */\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate\\n    );\\n\\n    /**\\n     * Update governance vote power of all involved delegates after tokens are transferred.\\n     *\\n     * This function **MUST** be called after each governance token transfer for the\\n     * delegates to reflect the correct balance.\\n     * @param _from Source address of the transfer.\\n     * @param _to Destination address of the transfer.\\n     * @param _fromBalance _Ignored._\\n     * @param _toBalance _Ignored._\\n     * @param _amount Amount being transferred.\\n     */\\n    function updateAtTokenTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * Set the cleanup block number.\\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased.\\n     * History before that block should never be used since it can be inconsistent.\\n     * In particular, cleanup block number must be lower than the current vote power block.\\n     * @param _blockNumber The new cleanup block number.\\n     */\\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\\n\\n    /**\\n     * Set the contract that is allowed to call history cleaning methods.\\n     * @param _cleanerContract Address of the cleanup contract.\\n     * Usually this will be an instance of `CleanupBlockNumberManager`.\\n     */\\n    function setCleanerContract(address _cleanerContract) external;\\n\\n    /**\\n     * Get the token that this governance vote power contract belongs to.\\n     * @return The IVPToken interface owning this contract.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n\\n    /**\\n     * Get the stake mirror contract that this governance vote power contract belongs to.\\n     * @return The IPChainStakeMirror interface owning this contract.\\n     */\\n    function pChainStakeMirror() external view returns (IPChainStakeMirror);\\n\\n    /**\\n     * Get the current cleanup block number set with `setCleanupBlockNumber()`.\\n     * @return The currently set cleanup block number.\\n     */\\n    function getCleanupBlockNumber() external view returns(uint256);\\n}\\n\",\"keccak256\":\"0x3b175c30e7c500b9d8af13de07e631ab86b0ffce10917b0285cd06137f15be1a\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interface/IIVPContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IVPContractEvents.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPContract is IICleanable, IVPContractEvents {\\n    /**\\n     * Update vote powers when tokens are transfered.\\n     * Also update delegated vote powers for percentage delegation\\n     * and check for enough funds for explicit delegations.\\n     **/\\n    function updateAtTokenTransfer(\\n        address _from, \\n        address _to, \\n        uint256 _fromBalance,\\n        uint256 _toBalance,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\\n     **/\\n    function delegate(\\n        address _from, \\n        address _to, \\n        uint256 _balance, \\n        uint256 _bips\\n    ) external;\\n    \\n    /**\\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\\n     * @param _from The address of the delegator\\n     * @param _to The address of the recipient\\n     * @param _balance The delegator's current balance\\n     * @param _amount An explicit vote power amount to be delegated.\\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\\n     **/    \\n    function delegateExplicit(\\n        address _from, \\n        address _to, \\n        uint256 _balance, \\n        uint _amount\\n    ) external;    \\n\\n    /**\\n     * @notice Revoke all delegation from sender to `_who` at given block. \\n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\\n     *    Block `_blockNumber` must be in the past. \\n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\\n     * @param _from The address of the delegator\\n     * @param _who Address of the delegatee\\n     * @param _balance The delegator's current balance\\n     * @param _blockNumber The block number at which to revoke delegation.\\n     **/\\n    function revokeDelegationAt(\\n        address _from, \\n        address _who, \\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external;\\n    \\n        /**\\n     * @notice Undelegate all voting power for delegates of `msg.sender`\\n     *    Can only be used with percentage delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     **/\\n    function undelegateAll(\\n        address _from,\\n        uint256 _balance\\n    ) external;\\n    \\n    /**\\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\\n     *    Can only be used with explicit delegation.\\n     *    Does not reset delegation mode back to NOTSET.\\n     * @param _from The address of the delegator\\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \\n     *   so the caller must supply them.\\n     * @return The amount still delegated (in case the list of delegates was incomplete).\\n     */\\n    function undelegateAllExplicit(\\n        address _from, \\n        address[] memory _delegateAddresses\\n    ) external returns (uint256);\\n    \\n    /**\\n    * @notice Get the vote power of `_who` at block `_blockNumber`\\n    *   Reads/updates cache and upholds revocations.\\n    * @param _who The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_who` at `_blockNumber`.\\n    */\\n    function votePowerOfAtCached(address _who, uint256 _blockNumber) external returns(uint256);\\n    \\n    /**\\n     * @notice Get the current vote power of `_who`.\\n     * @param _who The address to get voting power.\\n     * @return Current vote power of `_who`.\\n     */\\n    function votePowerOf(address _who) external view returns(uint256);\\n    \\n    /**\\n    * @notice Get the vote power of `_who` at block `_blockNumber`\\n    * @param _who The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_who` at `_blockNumber`.\\n    */\\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n    * @notice Get the vote power of `_who` at block `_blockNumber`, ignoring revocation information (and cache).\\n    * @param _who The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_who` at `_blockNumber`. Result doesn't change if vote power is revoked.\\n    */\\n    function votePowerOfAtIgnoringRevocation(address _who, uint256 _blockNumber) external view returns(uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */    \\n    function batchVotePowerOfAt(\\n        address[] memory _owners, \\n        uint256 _blockNumber\\n    )\\n        external view returns(uint256[] memory);\\n\\n    /**\\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\\n    * @param _from Address of delegator\\n    * @param _to Address of delegatee\\n    * @param _balance The delegator's current balance\\n    * @return The delegated vote power.\\n    */\\n    function votePowerFromTo(\\n        address _from, \\n        address _to, \\n        uint256 _balance\\n    ) external view returns(uint256);\\n    \\n    /**\\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\\n    * @param _from Address of delegator\\n    * @param _to Address of delegatee\\n    * @param _balance The delegator's current balance\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The delegated vote power.\\n    */\\n    function votePowerFromToAt(\\n        address _from, \\n        address _to, \\n        uint256 _balance,\\n        uint _blockNumber\\n    ) external view returns(uint256);\\n\\n    /**\\n     * @notice Compute the current undelegated vote power of `_owner`\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _balance Owner's current balance\\n     * @return The unallocated vote power of `_owner`\\n     */\\n    function undelegatedVotePowerOf(\\n        address _owner,\\n        uint256 _balance\\n    ) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the undelegated vote power of `_owner` at given block.\\n     * @param _owner The address to get undelegated voting power.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\\n     */\\n    function undelegatedVotePowerOfAt(\\n        address _owner, \\n        uint256 _balance,\\n        uint256 _blockNumber\\n    ) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\\n     *  allocated by percentage or by explicit value.\\n     * @param _who The address to get delegation mode.\\n     * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))\\n     */\\n    function delegationModeOf(address _who) external view returns (uint256);\\n    \\n    /**\\n    * @notice Get the vote power delegation `_delegateAddresses` \\n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n    * @param _owner The address to get delegations.\\n    * @return _delegateAddresses Positional array of delegation addresses.\\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n    * @return _count The number of delegates.\\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n    */\\n    function delegatesOf(\\n        address _owner\\n    )\\n        external view \\n        returns (\\n            address[] memory _delegateAddresses, \\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n    * @notice Get the vote power delegation `delegationAddresses` \\n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\\n    * @param _owner The address to get delegations.\\n    * @param _blockNumber The block for which we want to know the delegations.\\n    * @return _delegateAddresses Positional array of delegation addresses.\\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\\n    * @return _count The number of delegates.\\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\\n    */\\n    function delegatesOfAt(\\n        address _owner,\\n        uint256 _blockNumber\\n    )\\n        external view \\n        returns (\\n            address[] memory _delegateAddresses, \\n            uint256[] memory _bips,\\n            uint256 _count,\\n            uint256 _delegationMode\\n        );\\n\\n    /**\\n     * The VPToken (or some other contract) that owns this VPContract.\\n     * All state changing methods may be called only from this address.\\n     * This is because original msg.sender is sent in `_from` parameter\\n     * and we must be sure that it cannot be faked by directly calling VPContract.\\n     * Owner token is also used in case of replacement to recover vote powers from balances.\\n     */\\n    function ownerToken() external view returns (IVPToken);\\n    \\n    /**\\n     * Return true if this IIVPContract is configured to be used as a replacement for other contract.\\n     * It means that vote powers are not necessarily correct at the initialization, therefore\\n     * every method that reads vote power must check whether it is initialized for that address and block.\\n     */\\n    function isReplacement() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfe46d34aedaf90b8835574b9cdcec39bb51e0bd00d79bb0e2c4ad51aaed417ba\",\"license\":\"MIT\"},\"@flarenetwork/flare-periphery-contracts/coston2/token/interface/IIVPToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9;\\n\\nimport \\\"../../IVPToken.sol\\\";\\nimport \\\"../../IGovernanceVotePower.sol\\\";\\nimport \\\"./IIVPContract.sol\\\";\\nimport \\\"./IIGovernanceVotePower.sol\\\";\\nimport \\\"./IICleanable.sol\\\";\\n\\ninterface IIVPToken is IVPToken, IICleanable {\\n    /**\\n     * Set the contract that is allowed to set cleanupBlockNumber.\\n     * Usually this will be an instance of CleanupBlockNumberManager.\\n     */\\n    function setCleanupBlockNumberManager(address _cleanupBlockNumberManager) external;\\n    \\n    /**\\n     * Sets new governance vote power contract that allows token owners to participate in governance voting\\n     * and delegate governance vote power. \\n     */\\n    function setGovernanceVotePower(IIGovernanceVotePower _governanceVotePower) external;\\n    \\n    /**\\n    * @notice Get the total vote power at block `_blockNumber` using cache.\\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n    *   Can only be used if `_blockNumber` is in the past, otherwise reverts.    \\n    * @param _blockNumber The block number at which to fetch.\\n    * @return The total vote power at the block (sum of all accounts' vote powers).\\n    */\\n    function totalVotePowerAtCached(uint256 _blockNumber) external returns(uint256);\\n    \\n    /**\\n    * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.\\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\\n    *   Can only be used if _blockNumber is in the past, otherwise reverts.    \\n    * @param _owner The address to get voting power.\\n    * @param _blockNumber The block number at which to fetch.\\n    * @return Vote power of `_owner` at `_blockNumber`.\\n    */\\n    function votePowerOfAtCached(address _owner, uint256 _blockNumber) external returns(uint256);\\n\\n    /**\\n     * Return vote powers for several addresses in a batch.\\n     * @param _owners The list of addresses to fetch vote power of.\\n     * @param _blockNumber The block number at which to fetch.\\n     * @return A list of vote powers.\\n     */    \\n    function batchVotePowerOfAt(\\n        address[] memory _owners, \\n        uint256 _blockNumber\\n    ) external view returns(uint256[] memory);\\n}\\n\",\"keccak256\":\"0x66a179df6d76a8270dd0f2532a3c565eed4a6fd53b6fca1f657cf22be12acac0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"contracts/VolatilityLottery.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {TestFtsoV2Interface} from \\\"@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol\\\";\\nimport {ContractRegistry} from \\\"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\\\";\\n\\ncontract VolatilityLottery {\\n\\n    bytes21 public constant FLR_USD_ID = 0x01464c522f55534400000000000000000000000000; // FLR/USD\\n    bytes21 public constant BTC_USD_ID = 0x014254432f55534400000000000000000000000000; // BTC/USD\\n    bytes21 public constant ETH_USD_ID = 0x014554482f55534400000000000000000000000000; // ETH/USD\\n\\n    uint256 public lotteryThreshold = 1e18; // Price change threshold for volatility (e.g., 1% change)\\n    uint256 public lotteryEndTime;\\n    uint256 public roundId;\\n    bool public isRoundActive;\\n    \\n    address[] public participants;\\n    mapping(address => uint256) public participantBalances;\\n\\n    event LotteryEntered(address indexed participant, uint256 amount);\\n    event LotteryStarted(uint256 startTime);\\n    event LotteryEnded(address winner, uint256 prizeAmount);\\n    event RoundStarted(uint256 indexed roundId, uint256 startTime, uint256 endTime);\\n\\n    // Get the latest price feed for FLR/USD\\n    function getFlrUsdPrice() internal view returns (uint256 price) {\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        (price, ) = ftsoV2.getFeedByIdInWei(FLR_USD_ID);\\n    }\\n\\n    // Get the latest price feed for BTC/USD\\n    function getBtcUsdPrice() internal view returns (uint256 price) {\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        (price, ) = ftsoV2.getFeedByIdInWei(BTC_USD_ID);\\n    }\\n\\n    // Get the latest price feed for ETH/USD\\n    function getEthUsdPrice() internal view returns (uint256 price) {\\n        TestFtsoV2Interface ftsoV2 = ContractRegistry.getTestFtsoV2();\\n        (price, ) = ftsoV2.getFeedByIdInWei(ETH_USD_ID);\\n    }\\n\\n    // Enter the lottery with an amount of tokens or ETH\\n    function enterLottery(uint256 amount) external payable {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(isRoundActive, \\\"No active round\\\");\\n        require(block.timestamp < lotteryEndTime, \\\"Round has ended\\\");\\n        require(msg.value == amount, \\\"Amount must match sent ETH\\\");\\n        \\n        participantBalances[msg.sender] += amount;\\n        participants.push(msg.sender);\\n        emit LotteryEntered(msg.sender, amount);\\n    }\\n\\n    // Start a new lottery round\\n    function startRound() external {\\n        require(!isRoundActive, \\\"A round is already active\\\");\\n        \\n        // Get price feeds to check volatility\\n        uint256 priceFlrUsd = getFlrUsdPrice();\\n        uint256 priceBtcUsd = getBtcUsdPrice();\\n        uint256 priceEthUsd = getEthUsdPrice();\\n        \\n        uint256 flrPriceDifference = calculatePriceChange(priceFlrUsd, FLR_USD_ID);\\n        uint256 btcPriceDifference = calculatePriceChange(priceBtcUsd, BTC_USD_ID);\\n        uint256 ethPriceDifference = calculatePriceChange(priceEthUsd, ETH_USD_ID);\\n\\n        bool volatilityThresholdMet = flrPriceDifference > lotteryThreshold || \\n                                      btcPriceDifference > lotteryThreshold || \\n                                      ethPriceDifference > lotteryThreshold;\\n        \\n        if (volatilityThresholdMet) {\\n            // Increment round ID\\n            roundId++;\\n            \\n            // Set round timing\\n            uint256 startTime = block.timestamp;\\n            uint256 endTime = startTime + 10 minutes;\\n            lotteryEndTime = endTime;\\n            \\n            // Mark round as active\\n            isRoundActive = true;\\n            \\n            emit RoundStarted(roundId, startTime, endTime);\\n            emit LotteryStarted(startTime); // For backward compatibility\\n        }\\n    }\\n\\n    // Calculate price change percentage between the current and last recorded price\\n    function calculatePriceChange(uint256 currentPrice, bytes21 feedId) internal view returns (uint256) {\\n        uint256 lastPrice = participantBalances[address(this)]; // Placeholder for the actual last price storage\\n        if (lastPrice == 0) {\\n            return 0;\\n        }\\n        uint256 priceChange = (currentPrice > lastPrice) ? currentPrice - lastPrice : lastPrice - currentPrice;\\n        return priceChange;\\n    }\\n\\n    // End the lottery by selecting a random winner\\n    function endLottery() public {\\n        require(isRoundActive, \\\"No active round\\\");\\n        require(block.timestamp >= lotteryEndTime, \\\"Round has not ended yet\\\");\\n        \\n        // Reset round status\\n        isRoundActive = false;\\n        \\n        if (participants.length == 0) {\\n            return; // No participants, no winner\\n        }\\n\\n        uint256 winnerIndex = uint256(blockhash(block.number - 1)) % participants.length;\\n        address winner = participants[winnerIndex];\\n        uint256 prizeAmount = address(this).balance; // The total prize pool\\n\\n        (bool success, ) = winner.call{value: prizeAmount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n\\n        emit LotteryEnded(winner, prizeAmount);\\n\\n        // Reset the lottery\\n        participants = new address[](0);\\n    }\\n\\n    // Function to fund the contract with ETH for the lottery pool\\n    function fundLottery() external payable {}\\n\\n    // Function to withdraw funds from the contract (admin)\\n    function withdrawFunds(uint256 amount) external {\\n        // Admin checks here (e.g., onlyOwner modifier)\\n        payable(msg.sender).transfer(amount);\\n    }\\n\\n    // Set the volatility threshold (admin function)\\n    function setLotteryThreshold(uint256 newThreshold) external {\\n        // Admin checks here (e.g., onlyOwner modifier)\\n        lotteryThreshold = newThreshold;\\n    }\\n\\n    // Set the end time for the lottery (admin function)\\n    function setLotteryEndTime(uint256 newEndTime) external {\\n        // Admin checks here (e.g., onlyOwner modifier)\\n        lotteryEndTime = newEndTime;\\n    }\\n    \\n    // Force end the current round (admin function)\\n    function forceEndRound() external {\\n        // Admin checks here (e.g., onlyOwner modifier)\\n        require(isRoundActive, \\\"No active round\\\");\\n        endLottery();\\n    }\\n    \\n    // Check if a round should be ended and end it if needed\\n    function checkAndEndRound() external {\\n        if (isRoundActive && block.timestamp >= lotteryEndTime) {\\n            endLottery();\\n        }\\n    }\\n}\",\"keccak256\":\"0x2868e4d0aee24190d64166f8ff8efaa3f8ee07b0a9ad79c5c6c8bf00d01847b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052670de0b6b3a764000060005534801561001c57600080fd5b50610d228061002c6000396000f3fe6080604052600436106101095760003560e01c806345945a4511610095578063ad97610c11610064578063ad97610c146102bc578063b5cc45391461016e578063bebefc6a146102d1578063c151ff1c146102ef578063d88632091461030557600080fd5b806345945a451461024757806355e3f086146102715780638cd221c914610286578063a2b20d601461029c57600080fd5b8063155dd5ee116100dc578063155dd5ee146101a35780631593a8c7146101c357806335c1d349146101d85780633fd430981461021057806343662a7e1461022357600080fd5b8063096bbd281461010e5780630b7ab3931461014e5780630b98519414610170578063107704b51461018e575b600080fd5b34801561011a57600080fd5b5061012c665193148bd554d160c21b81565b6040516affffffffffffffffffffff1990911681526020015b60405180910390f35b34801561015a57600080fd5b5061016e610169366004610b87565b600155565b005b34801561017c57600080fd5b5061012c665155120bd554d160c21b81565b34801561019a57600080fd5b5061016e610332565b3480156101af57600080fd5b5061016e6101be366004610b87565b610367565b3480156101cf57600080fd5b5061016e610398565b3480156101e457600080fd5b506101f86101f3366004610b87565b61055d565b6040516001600160a01b039091168152602001610145565b61016e61021e366004610b87565b610587565b34801561022f57600080fd5b5061023960015481565b604051908152602001610145565b34801561025357600080fd5b506003546102619060ff1681565b6040519015158152602001610145565b34801561027d57600080fd5b5061016e61072a565b34801561029257600080fd5b5061023960025481565b3480156102a857600080fd5b5061016e6102b7366004610b87565b600055565b3480156102c857600080fd5b5061016e6108c6565b3480156102dd57600080fd5b5061012c66509510cbd554d160c21b81565b3480156102fb57600080fd5b5061023960005481565b34801561031157600080fd5b50610239610320366004610bb8565b60056020526000908152604090205481565b60035460ff1661035d5760405162461bcd60e51b815260040161035490610bdc565b60405180910390fd5b610365610398565b565b604051339082156108fc029083906000818181858888f19350505050158015610394573d6000803e3d6000fd5b5050565b60035460ff166103ba5760405162461bcd60e51b815260040161035490610bdc565b60015442101561040c5760405162461bcd60e51b815260206004820152601760248201527f526f756e6420686173206e6f7420656e646564207965740000000000000000006044820152606401610354565b6003805460ff1916905560045460000361042257565b600454600090610433600143610c1b565b61043e919040610c2e565b905060006004828154811061045557610455610c50565b60009182526020822001546040516001600160a01b039091169250479190839083908381818185875af1925050503d80600081146104af576040519150601f19603f3d011682016040523d82523d6000602084013e6104b4565b606091505b50509050806104f75760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606401610354565b604080516001600160a01b0385168152602081018490527fa49efdde740c1e6a0e4eeb9e7b2c5f9305ca78fc5f61c672be3688209feade1b910160405180910390a1604080516000815260208101918290525161055691600491610b0d565b5050505050565b6004818154811061056d57600080fd5b6000918252602090912001546001600160a01b0316905081565b600081116105d75760405162461bcd60e51b815260206004820152601d60248201527f416d6f756e74206d7573742062652067726561746572207468616e20300000006044820152606401610354565b60035460ff166105f95760405162461bcd60e51b815260040161035490610bdc565b600154421061063c5760405162461bcd60e51b815260206004820152600f60248201526e149bdd5b99081a185cc8195b991959608a1b6044820152606401610354565b80341461068b5760405162461bcd60e51b815260206004820152601a60248201527f416d6f756e74206d757374206d617463682073656e74204554480000000000006044820152606401610354565b33600090815260056020526040812080548392906106aa908490610c66565b9091555050600480546001810182556000919091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b031916339081179091556040518281527fc28711c8dcc0cb3d25732e13809d1d8c2640669a0a3fb4f7729810a9caaffdff9060200160405180910390a250565b60035460ff161561077d5760405162461bcd60e51b815260206004820152601960248201527f4120726f756e6420697320616c726561647920616374697665000000000000006044820152606401610354565b60006107876108e7565b9050600061079361096e565b9050600061079f6109b2565b905060006107b784665193148bd554d160c21b6109f6565b905060006107cf8466509510cbd554d160c21b6109f6565b905060006107e784665155120bd554d160c21b6109f6565b9050600080548411806107fb575060005483115b80610807575060005482115b905080156108bd576002805490600061081f83610c79565b90915550429050600061083482610258610c66565b60018181556003805460ff19169091179055600254604080518581526020810184905292935090917fa359b664a68acd8839e42112eb50eff3408165e15074fde89ddb58a0db2e691d910160405180910390a26040518281527f3d01c4ba0165a3f9c01ca4916efd5efd92dd9ac07569ff74d7047c7cde6683499060200160405180910390a150505b50505050505050565b60035460ff1680156108da57506001544210155b1561036557610365610398565b6000806108f2610a44565b604051632cff56fb60e11b8152665193148bd554d160c21b60048201529091506001600160a01b038216906359feadf6906024015b6040805180830381865afa158015610943573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109679190610c92565b5092915050565b600080610979610a44565b604051632cff56fb60e11b815266509510cbd554d160c21b60048201529091506001600160a01b038216906359feadf690602401610927565b6000806109bd610a44565b604051632cff56fb60e11b8152665155120bd554d160c21b60048201529091506001600160a01b038216906359feadf690602401610927565b30600090815260056020526040812054808203610a17576000915050610a3e565b6000818511610a2f57610a2a8583610c1b565b610a39565b610a398286610c1b565b925050505b92915050565b600073ad67fe66660fb8dfe9d6b1b4240d8650e30f60196001600160a01b031663159354a2604051602001610a9390602080825260069082015265233a39b7ab1960d11b604082015260600190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610ac791815260200190565b602060405180830381865afa158015610ae4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b089190610ccf565b905090565b828054828255906000526020600020908101928215610b62579160200282015b82811115610b6257825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190610b2d565b50610b6e929150610b72565b5090565b5b80821115610b6e5760008155600101610b73565b600060208284031215610b9957600080fd5b5035919050565b6001600160a01b0381168114610bb557600080fd5b50565b600060208284031215610bca57600080fd5b8135610bd581610ba0565b9392505050565b6020808252600f908201526e139bc81858dd1a5d99481c9bdd5b99608a1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b81810381811115610a3e57610a3e610c05565b600082610c4b57634e487b7160e01b600052601260045260246000fd5b500690565b634e487b7160e01b600052603260045260246000fd5b80820180821115610a3e57610a3e610c05565b600060018201610c8b57610c8b610c05565b5060010190565b60008060408385031215610ca557600080fd5b82519150602083015167ffffffffffffffff81168114610cc457600080fd5b809150509250929050565b600060208284031215610ce157600080fd5b8151610bd581610ba056fea26469706673582212203760dc8f42f627b5772992ec1d9e2aaf9ccaa7543abde85be688d69696a038a164736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106101095760003560e01c806345945a4511610095578063ad97610c11610064578063ad97610c146102bc578063b5cc45391461016e578063bebefc6a146102d1578063c151ff1c146102ef578063d88632091461030557600080fd5b806345945a451461024757806355e3f086146102715780638cd221c914610286578063a2b20d601461029c57600080fd5b8063155dd5ee116100dc578063155dd5ee146101a35780631593a8c7146101c357806335c1d349146101d85780633fd430981461021057806343662a7e1461022357600080fd5b8063096bbd281461010e5780630b7ab3931461014e5780630b98519414610170578063107704b51461018e575b600080fd5b34801561011a57600080fd5b5061012c665193148bd554d160c21b81565b6040516affffffffffffffffffffff1990911681526020015b60405180910390f35b34801561015a57600080fd5b5061016e610169366004610b87565b600155565b005b34801561017c57600080fd5b5061012c665155120bd554d160c21b81565b34801561019a57600080fd5b5061016e610332565b3480156101af57600080fd5b5061016e6101be366004610b87565b610367565b3480156101cf57600080fd5b5061016e610398565b3480156101e457600080fd5b506101f86101f3366004610b87565b61055d565b6040516001600160a01b039091168152602001610145565b61016e61021e366004610b87565b610587565b34801561022f57600080fd5b5061023960015481565b604051908152602001610145565b34801561025357600080fd5b506003546102619060ff1681565b6040519015158152602001610145565b34801561027d57600080fd5b5061016e61072a565b34801561029257600080fd5b5061023960025481565b3480156102a857600080fd5b5061016e6102b7366004610b87565b600055565b3480156102c857600080fd5b5061016e6108c6565b3480156102dd57600080fd5b5061012c66509510cbd554d160c21b81565b3480156102fb57600080fd5b5061023960005481565b34801561031157600080fd5b50610239610320366004610bb8565b60056020526000908152604090205481565b60035460ff1661035d5760405162461bcd60e51b815260040161035490610bdc565b60405180910390fd5b610365610398565b565b604051339082156108fc029083906000818181858888f19350505050158015610394573d6000803e3d6000fd5b5050565b60035460ff166103ba5760405162461bcd60e51b815260040161035490610bdc565b60015442101561040c5760405162461bcd60e51b815260206004820152601760248201527f526f756e6420686173206e6f7420656e646564207965740000000000000000006044820152606401610354565b6003805460ff1916905560045460000361042257565b600454600090610433600143610c1b565b61043e919040610c2e565b905060006004828154811061045557610455610c50565b60009182526020822001546040516001600160a01b039091169250479190839083908381818185875af1925050503d80600081146104af576040519150601f19603f3d011682016040523d82523d6000602084013e6104b4565b606091505b50509050806104f75760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606401610354565b604080516001600160a01b0385168152602081018490527fa49efdde740c1e6a0e4eeb9e7b2c5f9305ca78fc5f61c672be3688209feade1b910160405180910390a1604080516000815260208101918290525161055691600491610b0d565b5050505050565b6004818154811061056d57600080fd5b6000918252602090912001546001600160a01b0316905081565b600081116105d75760405162461bcd60e51b815260206004820152601d60248201527f416d6f756e74206d7573742062652067726561746572207468616e20300000006044820152606401610354565b60035460ff166105f95760405162461bcd60e51b815260040161035490610bdc565b600154421061063c5760405162461bcd60e51b815260206004820152600f60248201526e149bdd5b99081a185cc8195b991959608a1b6044820152606401610354565b80341461068b5760405162461bcd60e51b815260206004820152601a60248201527f416d6f756e74206d757374206d617463682073656e74204554480000000000006044820152606401610354565b33600090815260056020526040812080548392906106aa908490610c66565b9091555050600480546001810182556000919091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b031916339081179091556040518281527fc28711c8dcc0cb3d25732e13809d1d8c2640669a0a3fb4f7729810a9caaffdff9060200160405180910390a250565b60035460ff161561077d5760405162461bcd60e51b815260206004820152601960248201527f4120726f756e6420697320616c726561647920616374697665000000000000006044820152606401610354565b60006107876108e7565b9050600061079361096e565b9050600061079f6109b2565b905060006107b784665193148bd554d160c21b6109f6565b905060006107cf8466509510cbd554d160c21b6109f6565b905060006107e784665155120bd554d160c21b6109f6565b9050600080548411806107fb575060005483115b80610807575060005482115b905080156108bd576002805490600061081f83610c79565b90915550429050600061083482610258610c66565b60018181556003805460ff19169091179055600254604080518581526020810184905292935090917fa359b664a68acd8839e42112eb50eff3408165e15074fde89ddb58a0db2e691d910160405180910390a26040518281527f3d01c4ba0165a3f9c01ca4916efd5efd92dd9ac07569ff74d7047c7cde6683499060200160405180910390a150505b50505050505050565b60035460ff1680156108da57506001544210155b1561036557610365610398565b6000806108f2610a44565b604051632cff56fb60e11b8152665193148bd554d160c21b60048201529091506001600160a01b038216906359feadf6906024015b6040805180830381865afa158015610943573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109679190610c92565b5092915050565b600080610979610a44565b604051632cff56fb60e11b815266509510cbd554d160c21b60048201529091506001600160a01b038216906359feadf690602401610927565b6000806109bd610a44565b604051632cff56fb60e11b8152665155120bd554d160c21b60048201529091506001600160a01b038216906359feadf690602401610927565b30600090815260056020526040812054808203610a17576000915050610a3e565b6000818511610a2f57610a2a8583610c1b565b610a39565b610a398286610c1b565b925050505b92915050565b600073ad67fe66660fb8dfe9d6b1b4240d8650e30f60196001600160a01b031663159354a2604051602001610a9390602080825260069082015265233a39b7ab1960d11b604082015260600190565b604051602081830303815290604052805190602001206040518263ffffffff1660e01b8152600401610ac791815260200190565b602060405180830381865afa158015610ae4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b089190610ccf565b905090565b828054828255906000526020600020908101928215610b62579160200282015b82811115610b6257825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190610b2d565b50610b6e929150610b72565b5090565b5b80821115610b6e5760008155600101610b73565b600060208284031215610b9957600080fd5b5035919050565b6001600160a01b0381168114610bb557600080fd5b50565b600060208284031215610bca57600080fd5b8135610bd581610ba0565b9392505050565b6020808252600f908201526e139bc81858dd1a5d99481c9bdd5b99608a1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b81810381811115610a3e57610a3e610c05565b600082610c4b57634e487b7160e01b600052601260045260246000fd5b500690565b634e487b7160e01b600052603260045260246000fd5b80820180821115610a3e57610a3e610c05565b600060018201610c8b57610c8b610c05565b5060010190565b60008060408385031215610ca557600080fd5b82519150602083015167ffffffffffffffff81168114610cc457600080fd5b809150509250929050565b600060208284031215610ce157600080fd5b8151610bd581610ba056fea26469706673582212203760dc8f42f627b5772992ec1d9e2aaf9ccaa7543abde85be688d69696a038a164736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7709,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "lotteryThreshold",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 7711,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "lotteryEndTime",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 7713,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "roundId",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 7715,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "isRoundActive",
        "offset": 0,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 7718,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "participants",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 7722,
        "contract": "contracts/VolatilityLottery.sol:VolatilityLottery",
        "label": "participantBalances",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}