{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/VolatilityLottery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract VolatilityLottery {\n\n    address public flrTokenAddress;\n    IERC20 public flrToken;\n\n    bytes21 public constant FLR_USD_ID = 0x01464c522f55534400000000000000000000000000; // FLR/USD\n    bytes21 public constant BTC_USD_ID = 0x014254432f55534400000000000000000000000000; // BTC/USD\n    bytes21 public constant ETH_USD_ID = 0x014554482f55534400000000000000000000000000; // ETH/USD\n\n    uint256 public lotteryThreshold = 1e18; // Price change threshold for volatility (e.g., 1% change)\n    uint256 public lotteryEndTime;\n    uint256 public roundId = 0;\n    uint256 public roundDuration = 10 minutes;\n    bool public isRoundActive = false;\n    \n    address[] public participants;\n    mapping(address => uint256) public participantBalances;\n    mapping(uint256 => uint256) public roundStartTimes;\n    mapping(uint256 => uint256) public roundEndTimes;\n\n    event LotteryEntered(address indexed participant, uint256 amount);\n    event LotteryEnded(address winner, uint256 prizeAmount);\n    event RoundStarted(uint256 indexed roundId, uint256 startTime, uint256 endTime);\n\n    constructor(address _flrTokenAddress) {\n        flrTokenAddress = _flrTokenAddress;\n        flrToken = IERC20(flrTokenAddress);\n    }\n\n    // Get the latest price feed for FLR/USD\n    function getFlrUsdPrice() internal view returns (uint256 price) {\n        // Implement price fetching logic here\n        return 1e18; // Placeholder\n    }\n\n    // Get the latest price feed for BTC/USD\n    function getBtcUsdPrice() internal view returns (uint256 price) {\n        // Implement price fetching logic here\n        return 30000e18; // Placeholder\n    }\n\n    // Get the latest price feed for ETH/USD\n    function getEthUsdPrice() internal view returns (uint256 price) {\n        // Implement price fetching logic here\n        return 2000e18; // Placeholder\n    }\n\n    // Start a new lottery round\n    function startRound() external {\n        require(!isRoundActive, \"A round is already active\");\n        \n        // Increment round ID\n        roundId++;\n        \n        // Set round start and end times\n        uint256 startTime = block.timestamp;\n        uint256 endTime = startTime + roundDuration;\n        \n        roundStartTimes[roundId] = startTime;\n        roundEndTimes[roundId] = endTime;\n        lotteryEndTime = endTime;\n        \n        // Mark round as active\n        isRoundActive = true;\n        \n        emit RoundStarted(roundId, startTime, endTime);\n    }\n\n    // Enter the lottery with FLR tokens\n    function enterLottery(uint256 amount) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(isRoundActive, \"No active round\");\n        require(block.timestamp < lotteryEndTime, \"Round has ended\");\n\n        // Transfer FLR tokens from the sender to the contract\n        bool success = flrToken.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n\n        participantBalances[msg.sender] += amount;\n        participants.push(msg.sender);\n        emit LotteryEntered(msg.sender, amount);\n    }\n\n    // Trigger the lottery based on price volatility\n    function checkVolatilityAndTriggerLottery() external {\n        require(isRoundActive, \"No active round\");\n        \n        uint256 priceFlrUsd = getFlrUsdPrice();\n        uint256 priceBtcUsd = getBtcUsdPrice();\n        uint256 priceEthUsd = getEthUsdPrice();\n        \n        uint256 flrPriceDifference = calculatePriceChange(priceFlrUsd, FLR_USD_ID);\n        uint256 btcPriceDifference = calculatePriceChange(priceBtcUsd, BTC_USD_ID);\n        uint256 ethPriceDifference = calculatePriceChange(priceEthUsd, ETH_USD_ID);\n\n        bool volatilityThresholdMet = flrPriceDifference > lotteryThreshold || \n                                      btcPriceDifference > lotteryThreshold || \n                                      ethPriceDifference > lotteryThreshold;\n\n        // If volatility threshold is met or round has ended\n        if (volatilityThresholdMet || block.timestamp > lotteryEndTime) {\n            endLottery();\n        }\n    }\n\n    // Calculate price change percentage between the current and last recorded price\n    function calculatePriceChange(uint256 currentPrice, bytes21 feedId) internal view returns (uint256) {\n        // For simplicity, we can compare the current price to a stored \"last price\"\n        uint256 lastPrice = participantBalances[address(this)];\n        if (lastPrice == 0) {\n            return 0;\n        }\n        uint256 priceChange = (currentPrice > lastPrice) ? currentPrice - lastPrice : lastPrice - currentPrice;\n        return priceChange;\n    }\n\n    // End the lottery by selecting a random winner\n    function endLottery() internal {\n        require(isRoundActive, \"No active round\");\n        \n        // Reset round status\n        isRoundActive = false;\n        \n        if (participants.length == 0) {\n            return; // No participants, no winner\n        }\n\n        uint256 winnerIndex = uint256(blockhash(block.number - 1)) % participants.length;\n        address winner = participants[winnerIndex];\n        \n        // Calculate prize amount - total FLR tokens in contract\n        uint256 prizeAmount = flrToken.balanceOf(address(this));\n\n        // Transfer tokens to winner\n        if (prizeAmount > 0) {\n            bool success = flrToken.transfer(winner, prizeAmount);\n            require(success, \"Transfer failed\");\n            emit LotteryEnded(winner, prizeAmount);\n        }\n\n        // Reset the lottery\n        participants = new address[](0);\n    }\n\n    // Force end the current round (admin function)\n    function forceEndRound() external {\n        // Admin checks here (e.g., onlyOwner modifier)\n        require(isRoundActive, \"No active round\");\n        endLottery();\n    }\n\n    // Fund the lottery with FLR tokens\n    function fundLottery(uint256 amount) external {\n        bool success = flrToken.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n    }\n\n    // Function to withdraw FLR tokens from the contract (admin)\n    function withdrawFunds(uint256 amount) external {\n        // Admin checks here (e.g., onlyOwner modifier)\n        bool success = flrToken.transfer(msg.sender, amount);\n        require(success, \"Transfer failed\");\n    }\n\n    // Set the volatility threshold (admin function)\n    function setLotteryThreshold(uint256 newThreshold) external {\n        // Admin checks here (e.g., onlyOwner modifier)\n        lotteryThreshold = newThreshold;\n    }\n\n    // Set the round duration (admin function)\n    function setRoundDuration(uint256 newDuration) external {\n        // Admin checks here (e.g., onlyOwner modifier)\n        roundDuration = newDuration;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}